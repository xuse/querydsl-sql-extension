package com.ezviz.vas.simcard.device.common.model;

import java.sql.Types;
import java.util.Date;

import com.github.xuse.querydsl.annotation.AutoGenerated;
import com.github.xuse.querydsl.annotation.GeneratedType;
import com.github.xuse.querydsl.annotation.UnsavedValue;
import com.github.xuse.querydsl.annotation.dbdef.Check;
import com.github.xuse.querydsl.annotation.dbdef.ColumnSpec;
import com.github.xuse.querydsl.annotation.dbdef.Key;
import com.github.xuse.querydsl.annotation.dbdef.TableSpec;
import com.github.xuse.querydsl.sql.ddl.ConstraintType;
import com.github.xuse.querydsl.types.CodeEnum;

import lombok.Data;


/**
 * 数据延迟队列实现
 * 1\ 获取任务，实例先生成一个自己的唯一标识，例如IP地址，加上时间戳，形成'192.168.1.22:13438834584'格式
 * update  db_task_queue set runner = '192.168.1.22:13438834584',status='CHECKOUT',modified=current_timestamp  where status = 'TODO' AND runner='' AND must_later_than < current_timestamp LIMIT 10 
 * 更新成功则为任务签出。上例一次最多获得10条任务。
 * 
 * 2\ 查询获得的任务，并开始执行
 * select *from db_task_queue where status = 'CHECKOUT' AND runner='192.168.1.22:13438834584' order by created asc
 * 
 * 3\任务完成后，更新结果回数据库，一条一次更新。不做批量
 * - 如果需要重试
 * update  db_task_queue set runner = '',status='TODO',must_later_than=重试延迟时间,retries=retries+1,modified=current_timestamp where id=? and runner = '192.168.1.22:13438834584'
 *  
 * - 如果成功方案1 （更新为成功）
 * update  db_task_queue set result='success...',runner = '',status='SUCCESS',modified=current_timestamp where id=? and runner = '192.168.1.22:13438834584'
 *  
 * - 如果成功方案2 （插入新表记录执行动作，当前表删除任务）
 * delete db_task_queue where id=? and runner = '192.168.1.22:13438834584'
 *  
 * - 如果失败且达到最大重试次数 
 * update  db_task_queue set result='错误原因',runner = '',status='FAILURE',modified=current_timestamp where id=? and runner = '192.168.1.22:13438834584' 
 *  where条件终增加runner，是确保执行完毕后如果时间过长造成任务被回收（见4），则可以感知到，从而缩小批次或触发人工干预。
 *  
 * 4、如果任务迁出后，执行者异常终止造成任务结果没有回写.通过定时任务回收(1小时1次)
 * 正常情况下数据库中checkout记录的比例很小，因此modified字段上无需加索引。如担心数量过大，可以增加LIMIT并多次处理。
 * select * from db_task_queue where status='CHECKOUT' and modified<current_timestamp - interval 1 hour update set status='TODO', runner='' where AND status='CHECKOUT'
 * 
 * 5、清理过期任务
 * 方案1
 * DELETE * from db_task_queue where status='SUCCESS' and modified<3~6个月前.
 * 
 * 方案2
 * 成功的记录插入到另外一张表，成功时直接删除此表记录，故不再需要清理。
 * 
 * ===========
 * 分区队列消费方案
 * 对于这类有序消费要求，从一开始直接走Kafka较为合适。数据库据适合定时重试，而定时重试意味着打乱顺序。
 * 因此这两种场景是有矛盾的。所以最终放弃基于数据库实现分区队列特性。
 */
@Data
@TableSpec(name = "db_task_queue", primaryKeys = { "id" }, keys = {
        @Key(name = "idx_task_queue_status_runner_type", path = { "status", "runner", "taskType" }, type = ConstraintType.KEY),
        @Key(name="idx_task_queue_unique",path= {"targetKey","taskType"},type=ConstraintType.UNIQUE)
    },
    checks = {
        @Check(name="check_1",value = "retries<=max_retries")
            
    },
    collate = "utf8_general_ci"
)
public class DbTaskQueue {
	/**
	 * 单表内的物理主键
	 */
	@ColumnSpec(name="id",type=Types.BIGINT,unsigned = true,autoIncrement = true,nullable = false)
	private long id;
	/**
	 * 任务类型，需索引
	 */
	@ColumnSpec(name="task_type",type=Types.VARCHAR,size = 12,nullable = false)
	private String taskType;
	/**
	 * 任务内容,JSON,具体格式由taskType决定
	 */
	@ColumnSpec(name="task_content",type = Types.VARCHAR,size = 512, nullable = false)
	private String taskContent;
	/**
	 * 任务来源
	 */
	@ColumnSpec(name="task_source",type=Types.VARCHAR,size=64,nullable = false)
	private String taskSource;
	
	/**
	 * 任务必须晚于指定时间执行
	 */
	@ColumnSpec(name="must_later_than",type=Types.TIMESTAMP)
	private Date mustLaterThan;
	/**
	 * 创建时间
	 */
	@ColumnSpec(type=Types.TIMESTAMP)
	@AutoGenerated(GeneratedType.CREATED_TIMESTAMP)
	private Date created;
	
	/**
	 * 更新时间
	 */
	@ColumnSpec(type=Types.TIMESTAMP)
	@AutoGenerated(GeneratedType.UPDATED_TIMESTAMP)
	private Date lastModified;
	
	/**
	 * 任务状态
	 */
	@ColumnSpec(name="task_status",type=Types.TINYINT,unsigned = true,nullable = false,defaultValue = "0")
	private TaskStatus status;
	
	/**
	 * 任务结果
	 */
	@ColumnSpec(name="task_result",type=Types.VARCHAR,size=64)
	private String result;
	
	/**
	 * 已重试次数
	 */
	@ColumnSpec(name="retries",type=Types.TINYINT,unsigned = true,nullable =false,defaultValue = "0")
	@UnsavedValue(UnsavedValue.MinusNumber)
	private int retries;
	
	/**
	 * 允许最大重试次数
	 * 0 不重试。仅执行一次
	 * 1 允许重试1次
	 */
	@ColumnSpec(name="max_retries",type=Types.TINYINT,unsigned = true,nullable =false,defaultValue = "0")
	@UnsavedValue(UnsavedValue.MinusNumber)
	private int maxRetries;
	
	/**
	 * 当前由哪个实例在运行
	 * 需要索引
	 */
	@ColumnSpec(name="runner",type = Types.VARCHAR,size = 32,nullable = false, defaultValue = "''")
	private String runner;
	
	/**
	 * 设备序列号等任务目标标识，用于特定业务的查询
	 */
	@ColumnSpec(name="target_key",type = Types.VARCHAR,size = 64,nullable = false, defaultValue = "''")
	private String targetKey;
	
	
	public static enum TaskStatus implements CodeEnum<TaskStatus>{
		/**
		 * 任务未完成的状态
		 */
		TODO(0),
		/**
		 * 任务成功后的状态
		 */
		SUCCESS(1),
		/**
		 * 任务失败后的状态
		 */
		FAILURE(2),
		/**
		 * 任务被执行服务签出正在执行的状态
		 */
		CHECKOUT(3);

	    public final int code;
	    
	    private TaskStatus(int code) {
	        this.code=code;
	    }
	    
        @Override
        public int getCode() {
            return code;
        }
	}
}
