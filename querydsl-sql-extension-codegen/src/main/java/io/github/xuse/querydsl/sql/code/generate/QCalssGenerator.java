package io.github.xuse.querydsl.sql.code.generate;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.function.Function;

import com.github.javaparser.ast.Modifier.Keyword;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.comments.BlockComment;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.xuse.querydsl.sql.RelationalPathBaseEx;
import com.github.xuse.querydsl.sql.column.AccessibleElement;
import com.github.xuse.querydsl.util.Assert;
import com.github.xuse.querydsl.util.Exceptions;
import com.querydsl.core.util.StringUtils;

import io.github.xuse.querydsl.sql.code.generate.PropertyPathCreaters.PathGenerator;
import io.github.xuse.querydsl.sql.code.generate.model.ClassImpl;
import io.github.xuse.querydsl.sql.code.generate.model.ClassMetadata;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

/**
 * 解析带注解的Java类，生成对应的QueryEntity
 */
@Slf4j
@Setter
public class QCalssGenerator {
	private Function<String,String> tableAliasCalcutor = QCalssGenerator::calcAlias;
	
	private Function<String,String> tableFieldCalculator =QCalssGenerator::clacField;
	
	private OutputDir outputDir = OutputDir.DIR_MAIN;

	
	/**
	 * Generate q class for entity class.
	 * @param entityClz 
	 * @return the file generated.
	 */
	public File generate(Class<?> entityClz) {
		log.info("Generating query class for {}",entityClz.getName());
		return generate(entityClz.getPackage().getName(),entityClz);
	}
	/**
	 * Generate q class for entity class.
	 * @param pkg target package name
	 * @param entityClz entity class.
	 * @return the file generated.
	 */
	public File generate(String pkg, Class<?> entityClz) {
		Assert.notNull(entityClz);
		String className = "Q" + entityClz.getSimpleName();
		CompilationUnitBuilder cu = generateContent(new ClassImpl(entityClz), pkg,className);
		File file = new File(outputDir.path + pkg.replace('.', '/') + "/" + className + ".java");
		File parent=file.getParentFile();
		if(!parent.exists()) {
			parent.mkdirs();
		}
		try (FileWriter writer = new FileWriter(file)) {
			writer.write(cu.build().toString());
		} catch (IOException e) {
			throw Exceptions.toRuntime(e);
		}
		return file;
	}

    public CompilationUnitBuilder generateContent(ClassMetadata entityClz, String pkgName, String qClassName) {
        CompilationUnitBuilder cu=CompilationUnitBuilder.create();
        cu.addImport(entityClz.getName());
        cu.setPackageDeclaration(pkgName);
        ClassOrInterfaceDeclaration clazz = cu.addClass(qClassName);
        clazz.setExtendedTypes(NodeList.nodeList(cu.createType(RelationalPathBaseEx.class, new ClassOrInterfaceType(null,entityClz.getSimpleName()))));
        
        clazz.setComment(new BlockComment("This class was generated by querydsl-sql-extension."));
        
        // 创建全局表模型实例
        ClassOrInterfaceType thisType = new ClassOrInterfaceType(null, qClassName);
        FieldDeclaration table = clazz.addField(thisType,tableFieldCalculator.apply(entityClz.getSimpleName()), Keyword.PUBLIC, Keyword.FINAL, Keyword.STATIC);
        ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();
        objectCreationExpr.setType(thisType);
        String alias =  this.tableAliasCalcutor.apply(entityClz.getSimpleName());
        objectCreationExpr.addArgument(new StringLiteralExpr(alias));
        table.getVariables().get(0).setInitializer(objectCreationExpr);
         List<AccessibleElement> fields = entityClz.getColumnFields();
        generateFields(clazz,cu,fields);

        // 创建构造
        ConstructorDeclaration constructor = clazz.addConstructor(com.github.javaparser.ast.Modifier.Keyword.PUBLIC);
        constructor.addParameter(String.class, "variable");
        BlockStmt body = constructor.getBody();
        MethodCallExpr superCall = new MethodCallExpr("super", new NameExpr(entityClz.getSimpleName()+".class"),
                new NameExpr("variable"));
        body.addStatement(superCall);
        MethodCallExpr scanMetadataCall = new MethodCallExpr("super.scanClassMetadata");
        body.addStatement(scanMetadataCall);
        return cu;
        
    }
    private void generateFields(ClassOrInterfaceDeclaration clazz, CompilationUnitBuilder cu, List<AccessibleElement> fields) {
	 // 各个字段描述
        for (AccessibleElement field : fields) {

            // 需要的
            String name = field.getName();
            PathGenerator generatgor = PropertyPathCreaters.getGenerator(field.getType());
            java.lang.reflect.Type fType=field.getGenericType();
            FieldDeclaration propPath = clazz.addField(generatgor.pathType(fType,cu), name, Keyword.PUBLIC, Keyword.FINAL);
            propPath.getVariable(0).setInitializer(generatgor.pathValue(fType,name,cu));
        }
    }
    public static String clacField(String simpleName) {
		return StringUtils.uncapitalize(simpleName);
	}
	
	public static String calcAlias(String simpleName) {
		StringBuilder sb = new StringBuilder();
		for (char c : simpleName.toCharArray()) {
			if (Character.isUpperCase(c)) {
				sb.append(Character.toLowerCase(c));
			}
		}
		if (sb.length() < 3) {
			return simpleName.substring(0, Math.min(3, simpleName.length())).toLowerCase();
		}
		return sb.toString();
	}
}
