package io.github.xuse.querydsl.sql.code.generate;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.function.Function;

import com.github.javaparser.ast.Modifier.Keyword;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.xuse.querydsl.annotation.dbdef.ColumnSpec;
import com.github.xuse.querydsl.sql.RelationalPathBaseEx;
import com.github.xuse.querydsl.util.Assert;
import com.github.xuse.querydsl.util.Exceptions;
import com.github.xuse.querydsl.util.TypeUtils;
import com.querydsl.sql.Column;

import io.github.xuse.querydsl.sql.code.generate.PropertyPathCreater.PathGenerator;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Setter
public class QCalssGenerator {
	public static final String DIR_TARGET="target/generated-sources/";
	public static final String DIR_MAIN="src/main/java/";
	public static final String DIR_TEST="src/test/java/";
	
	private Function<String,String> tableAliascalcutor = this::calcAlias;
	
	private String outputDir=DIR_MAIN;

	/**
	 * Generate q class for entity class.
	 * @param entityClz 
	 * @return the file generated.
	 */
	public File generate(Class<?> entityClz) {
		log.info("Generating query class for {}",entityClz.getName());
		return generate(entityClz.getPackage().getName(),entityClz);
	}
	/**
	 * Generate q class for entity class.
	 * @param pkg target package name
	 * @param entityClz entity class.
	 * @return the file generated.
	 */
	public File generate(String pkg, Class<?> entityClz) {
		Assert.notNull(entityClz);
		String className = "Q" + entityClz.getSimpleName();

		CompilationUnitBuilder cu=CompilationUnitBuilder.create();

		cu.addImport(entityClz);
		cu.setPackageDeclaration(pkg);
		ClassOrInterfaceDeclaration clazz = cu.addClass(className);
		//clazz.addOrphanComment(new LineComment("Generated by querydsl-sql-extension."));
		clazz.setExtendedTypes(NodeList.nodeList(cu.createType(RelationalPathBaseEx.class, entityClz)));
		
		// 创建全局表模型实例
		ClassOrInterfaceType thisType = new ClassOrInterfaceType(null, className);
		FieldDeclaration table = clazz.addField(thisType, "t", Keyword.PUBLIC, Keyword.FINAL, Keyword.STATIC);
		ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();
		objectCreationExpr.setType(thisType);
		String alias =  this.tableAliascalcutor.apply(entityClz.getSimpleName());
		objectCreationExpr.addArgument(new StringLiteralExpr(alias));
		table.getVariables().get(0).setInitializer(objectCreationExpr);

		// 各个字段描述
		for (Field field : TypeUtils.getAllDeclaredFields(entityClz)) {
			if (Modifier.isStatic(field.getModifiers())) {
				continue;
			}
			if (field.getAnnotation(Column.class) == null && field.getAnnotation(ColumnSpec.class) == null) {
				continue;
			}
			// 需要的
			String name = field.getName();
			PathGenerator generatgor = PropertyPathCreater.getGenerator(field.getType());
			java.lang.reflect.Type fType=field.getGenericType();
			FieldDeclaration propPath = clazz.addField(generatgor.pathType(fType,cu), name, Keyword.PUBLIC, Keyword.FINAL);
			propPath.getVariable(0).setInitializer(generatgor.pathValue(fType,name,cu));
		}

		// 创建构造
		ConstructorDeclaration constructor = clazz.addConstructor(com.github.javaparser.ast.Modifier.Keyword.PUBLIC);
		constructor.addParameter(String.class, "variable");
		BlockStmt body = constructor.getBody();
		MethodCallExpr superCall = new MethodCallExpr("super", new NameExpr(entityClz.getSimpleName()+".class"),
				new NameExpr("variable"));
		body.addStatement(superCall);
		MethodCallExpr scanMetadataCall = new MethodCallExpr("super.scanClassMetadata");
		body.addStatement(scanMetadataCall);

		// 将AST保存成Java文件
		File file = new File(outputDir + pkg.replace('.', '/') + "/" + className + ".java");
		try (FileWriter writer = new FileWriter(file)) {
			writer.write(cu.build().toString());
		} catch (IOException e) {
			throw Exceptions.toRuntime(e);
		}
		return file;
	}

	private String calcAlias(String simpleName) {
		StringBuilder sb = new StringBuilder();
		for (char c : simpleName.toCharArray()) {
			if (Character.isUpperCase(c)) {
				sb.append(Character.toLowerCase(c));
			}
		}
		if (sb.length() < 3) {
			return simpleName.substring(0, Math.min(3, simpleName.length())).toLowerCase();
		}
		return sb.toString();
	}
}
