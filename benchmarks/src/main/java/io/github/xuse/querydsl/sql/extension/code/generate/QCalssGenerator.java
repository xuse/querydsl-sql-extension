package io.github.xuse.querydsl.sql.extension.code.generate;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Modifier.Keyword;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.comments.LineComment;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.SimpleName;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.Type;
import com.github.xuse.querydsl.annotation.dbdef.ColumnSpec;
import com.github.xuse.querydsl.sql.RelationalPathBaseEx;
import com.github.xuse.querydsl.util.Exceptions;
import com.github.xuse.querydsl.util.TypeUtils;
import com.querydsl.core.types.PathMetadataFactory;
import com.querydsl.core.types.dsl.DateTimePath;
import com.querydsl.core.types.dsl.EnumPath;
import com.querydsl.core.types.dsl.NumberPath;
import com.querydsl.core.types.dsl.SimplePath;
import com.querydsl.core.types.dsl.StringPath;
import com.querydsl.sql.Column;

import io.github.xuse.querydsl.sql.extension.code.generate.PropertyPathCreater.PathGenerator;

public class QCalssGenerator {
	private static final String DIR_TARGET="target/generated-sources/";
	private static final String DIR_MAIN="src/main/java/";
	private static final String DIR_TEST="src/test/java/";

	
	public static void main(String[] args) {
		QCalssGenerator g=new QCalssGenerator();
		
	}
	
	
	private static final JavaParser p = new JavaParser();
	private String pkg;
	private Class<?> entityClz;
	private String defaultTableAlias;
	private String outputDir=DIR_MAIN;
	private String outputPackage;

	/*
	 * import java.util.Date; import java.util.Map;
	 * 
	 * import com.github.xuse.querydsl.enums.Gender; import
	 * com.github.xuse.querydsl.sql.RelationalPathBaseEx; import
	 * com.querydsl.core.types.PathMetadataFactory;
	 * 
	 * import com.querydsl.core.types.dsl.DateTimePath; import
	 * com.querydsl.core.types.dsl.EnumPath; import
	 * com.querydsl.core.types.dsl.NumberPath; import
	 * com.querydsl.core.types.dsl.SimplePath; import
	 * com.querydsl.core.types.dsl.StringPath;
	 * 
	 * public class QCaAsset extends RelationalPathBaseEx<CaAsset> {
	 * 
	 * private static final long serialVersionUID = -1972906214968601009L; public
	 * static final QCaAsset caAsset = new QCaAsset("as");
	 * 
	 * public final NumberPath<Integer> id = createNumber("id", int.class);
	 * 
	 * public QCaAsset(String variable) { super(CaAsset.class,
	 * PathMetadataFactory.forVariable(variable), "null", "CA_ASSET");
	 * super.scanClassMetadata(); }
	 */

	/**
	 * @param pkg
	 * @param entityClz
	 */
	public File generate(String pkg, Class<?> entityClz) {
		this.pkg = pkg;
		this.entityClz = entityClz;
		this.defaultTableAlias = calcAlias(entityClz.getSimpleName());
		this.outputPackage=entityClz.getPackageName();
		
		String className = "Q" + entityClz.getSimpleName();

		CompilationUnit cu = new CompilationUnit();

		cu.addImport(entityClz);
		cu.addImport(RelationalPathBaseEx.class);
		cu.addImport(PathMetadataFactory.class);
		cu.addImport(DateTimePath.class);
		cu.addImport(EnumPath.class);
		cu.addImport(NumberPath.class);
		cu.addImport(SimplePath.class);
		cu.addImport(StringPath.class);

		cu.setPackageDeclaration(pkg);
		ClassOrInterfaceDeclaration clazz = cu.addClass(className);
		clazz.addOrphanComment(new LineComment("Generated by querydsl-sql-extension."));

		ClassOrInterfaceType genericType = new ClassOrInterfaceType(null, entityClz.getSimpleName());
		ClassOrInterfaceType superType = new ClassOrInterfaceType(null, new SimpleName("RelationalPathBaseEx"),
				new NodeList<Type>(genericType));
		ClassOrInterfaceType thisType = new ClassOrInterfaceType(null, className);
		clazz.setExtendedType(0, superType);

		// 创建全局表模型实例
		FieldDeclaration table = clazz.addField(thisType, "t", Keyword.PUBLIC, Keyword.FINAL, Keyword.STATIC);
		ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();
		objectCreationExpr.setType(thisType);
		objectCreationExpr.addArgument(new StringLiteralExpr(defaultTableAlias));
		table.getVariables().get(0).setInitializer(objectCreationExpr);

		// 各个字段描述
		for (Field field : TypeUtils.getAllFields(entityClz)) {
			if (Modifier.isStatic(field.getModifiers())) {
				continue;
			}
			if (field.getAnnotation(Column.class) == null && field.getAnnotation(ColumnSpec.class) == null) {
				continue;
			}
			// 需要的
			String name = field.getName();
			PathGenerator generatgor = PropertyPathCreater.getGenerator(field.getType());

			FieldDeclaration propPath = clazz.addField(generatgor.pathType(), name, Keyword.PUBLIC, Keyword.FINAL);
			propPath.getVariable(0).setInitializer(generatgor.pathValue(field.getType()));
		}

		// 创建构造
		ConstructorDeclaration constructor = clazz.addConstructor(com.github.javaparser.ast.Modifier.Keyword.PUBLIC);
		constructor.addParameter(String.class, "variable");
		BlockStmt body = constructor.getBody();
		MethodCallExpr superCall = new MethodCallExpr("super", new NameExpr(entityClz.getSimpleName()+".class"),
				new NameExpr("PathMetadataFactory.forVariable(variable)"));
		body.addStatement(superCall);
		MethodCallExpr scanMetadataCall = new MethodCallExpr("super.scanClassMetadata");
		body.addStatement(scanMetadataCall);

		// 将AST保存成Java文件
		File file=new File(outputDir+outputPackage.replace('.', '/')+"/"+className+".java");
		try (FileWriter writer = new FileWriter(file)) {
			writer.write(cu.toString());
		} catch (IOException e) {
			throw Exceptions.toRuntime(e);
		}
		return file;
	}

	private String calcAlias(String simpleName) {
		StringBuilder sb = new StringBuilder();
		for (char c : simpleName.toCharArray()) {
			if (Character.isUpperCase(c)) {
				sb.append(Character.toLowerCase(c));
			}
		}
		if (sb.length() < 3) {
			return simpleName.substring(0, Math.min(3, simpleName.length())).toLowerCase();
		}
		return sb.toString();
	}
}
