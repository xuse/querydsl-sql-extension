package io.github.xuse.querydsl.sql.extension.code.generate;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

import com.github.javaparser.ast.Modifier.Keyword;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.comments.LineComment;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.xuse.querydsl.annotation.dbdef.ColumnSpec;
import com.github.xuse.querydsl.sql.RelationalPathBaseEx;
import com.github.xuse.querydsl.util.Exceptions;
import com.github.xuse.querydsl.util.TypeUtils;
import com.querydsl.core.types.PathMetadataFactory;
import com.querydsl.sql.Column;

import io.github.xuse.querydsl.sql.extension.code.generate.PropertyPathCreater.PathGenerator;

public class QCalssGenerator {
	public static final String DIR_TARGET="target/generated-sources/";
	public static final String DIR_MAIN="src/main/java/";
	public static final String DIR_TEST="src/test/java/";
	
	private String defaultTableAlias;
	private String outputDir=DIR_MAIN;
	private String outputPackage;


	/**
	 * @param pkg
	 * @param entityClz
	 */
	public File generate(String pkg, Class<?> entityClz) {
		this.defaultTableAlias = calcAlias(entityClz.getSimpleName());
		this.outputPackage=entityClz.getPackageName();
		
		String className = "Q" + entityClz.getSimpleName();

		CompilationUnitBuilder cu=CompilationUnitBuilder.create();

		cu.addImport(entityClz);
		cu.addImport(PathMetadataFactory.class);

		cu.setPackageDeclaration(pkg);
		ClassOrInterfaceDeclaration clazz = cu.addClass(className);
		clazz.addOrphanComment(new LineComment("Generated by querydsl-sql-extension."));
		clazz.setExtendedType(0, cu.createType(RelationalPathBaseEx.class, entityClz.getClasses()));

		// 创建全局表模型实例
		ClassOrInterfaceType thisType = new ClassOrInterfaceType(null, className);
		FieldDeclaration table = clazz.addField(thisType, "t", Keyword.PUBLIC, Keyword.FINAL, Keyword.STATIC);
		ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();
		objectCreationExpr.setType(thisType);
		objectCreationExpr.addArgument(new StringLiteralExpr(defaultTableAlias));
		table.getVariables().get(0).setInitializer(objectCreationExpr);

		// 各个字段描述
		for (Field field : TypeUtils.getAllDeclaredFields(entityClz)) {
			if (Modifier.isStatic(field.getModifiers())) {
				continue;
			}
			if (field.getAnnotation(Column.class) == null && field.getAnnotation(ColumnSpec.class) == null) {
				continue;
			}
			// 需要的
			String name = field.getName();
			PathGenerator generatgor = PropertyPathCreater.getGenerator(field.getType());
			java.lang.reflect.Type fType=field.getGenericType();
			FieldDeclaration propPath = clazz.addField(generatgor.pathType(fType,cu), name, Keyword.PUBLIC, Keyword.FINAL);
			propPath.getVariable(0).setInitializer(generatgor.pathValue(fType,name,cu));
		}

		// 创建构造
		ConstructorDeclaration constructor = clazz.addConstructor(com.github.javaparser.ast.Modifier.Keyword.PUBLIC);
		constructor.addParameter(String.class, "variable");
		BlockStmt body = constructor.getBody();
		MethodCallExpr superCall = new MethodCallExpr("super", new NameExpr(entityClz.getSimpleName()+".class"),
				new NameExpr("PathMetadataFactory.forVariable(variable)"));
		body.addStatement(superCall);
		MethodCallExpr scanMetadataCall = new MethodCallExpr("super.scanClassMetadata");
		body.addStatement(scanMetadataCall);

		// 将AST保存成Java文件
		File file=new File(outputDir+outputPackage.replace('.', '/')+"/"+className+".java");
		try (FileWriter writer = new FileWriter(file)) {
			writer.write(cu.build().toString());
		} catch (IOException e) {
			throw Exceptions.toRuntime(e);
		}
		return file;
	}

	private String calcAlias(String simpleName) {
		StringBuilder sb = new StringBuilder();
		for (char c : simpleName.toCharArray()) {
			if (Character.isUpperCase(c)) {
				sb.append(Character.toLowerCase(c));
			}
		}
		if (sb.length() < 3) {
			return simpleName.substring(0, Math.min(3, simpleName.length())).toLowerCase();
		}
		return sb.toString();
	}
}
