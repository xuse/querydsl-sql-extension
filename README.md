# Querydsl-sql-extension

**An enhancement for Querydsl based on module 'querydsl-sql'.**

[English](README.md)| [中文](README_cn.md)

This framework is an extension of [Querydsl-sql](https://github.com/querydsl/querydsl). The usage guide for Querydsl-sql can be found in the official documentation [Querying SQL](http://querydsl.com/static/querydsl/latest/reference/html/ch02s03.html).

**Table of Contents**

- [Querydsl-sql-extension](#querydsl-sql-extension)
  - [Introduction](#introduction)
  - [Features](#features)
    - [Usability Improvments](#usability-improvments)
    - [Database access security](#database-access-security)
    - [Performance Optimization](#performance-optimization)
    - [R2dbc support](#r2dbc-support)
    - [Other Functionality Enhancements](#other-functionality-enhancements)
      - [Database Structure Modeling](#database-structure-modeling)
      - [Pure POJO Usage (No QueryClass)](#pure-pojo-usage-no-queryclass)
      - [Multiple Styles of Low-code API](#multiple-styles-of-low-code-api)
      - [Access and Modification of Database Structure (DDL)](#access-and-modification-of-database-structure-ddl)
      - [Record Object mapping to database Relation](#record-object-mapping-to-database-relation)
    - [Runtime Environment and Scope of Application](#runtime-environment-and-scope-of-application)
  - [Experimental Features](#experimental-features)
    - [Partition Management (Supported for MySQL and PostgreSQL)](#partition-management-supported-for-mysql-and-postgresql)
    - [DDL Support](#ddl-support)
    - [MySQL Online DDL](#mysql-online-ddl)
  - [FAQ](#faq)


## Introduction

**What is Querydsl? Why choose it？/ Introduction**
See [Why QueryDSL (Chinese)](static/why_querydsl.md)

Note: This framework is not based on `querydsl-jpa`, but is an extension of `querydsl-sql`. For a comparison with JPA mode, 
please refer to [Why QueryDSL](static/why_querydsl.md). If you want to integrate this module into a project with querydsl-jpa, please refer to the following section (Using with query-jpa).

**ChangeLogs**
[ChangeLogs](changelogs.md)

**Manuals**
See [User Guide](static/user_guide.md)

**Import from repository**
```xml
<dependency>
	<groupId>io.github.xuse</groupId>
	<artifactId>querydsl-sql-extension</artifactId>
	<version>5.0.0-r120</version>
</dependency>
```

If you need to integrate with Spring Framework, you also need to: 
```xml
<dependency>
	<groupId>io.github.xuse</groupId>
	<artifactId>querydsl-sql-extension-spring</artifactId>
	<version>5.0.0-r120</version>
</dependency>
```

**Using With Querydsl-JPA**
To use them together, two issues need to be addressed:

1. The Query class generated by Querydsl-sql inherit from com.querydsl.sql.RelationalPath, but the Query class in JPA inherits from com.querydsl.core.types.EntityPath, which is not consistent with the former. This problem can be solved by using the querydsl-entityql framework (https://github.com/eXsio/querydsl-entityql), which can convert the querydsl-jpa model to the querydsl-sql model.
2. Querydsl-jpa defaults to using the Hibernate Session/EntityManager for a `JpaTransactionManager`. QueryDSL-sql is using `JdbcTransactionManager` based on a JDBC DataSource, so they can not share transaction with each other. You need to handle this problem with some programming restrctions.



## Features

### Usability Improvments
* Providing the @CustomType annotation to map complex beans to database fields.

**Example**

  ```java
      //Using a string type to mapping a column of timestamp in database.
      @CustomType(value=StringAsDateTimeType.class,parameters = "MM/dd/yyyy HH:mm:ss")
      private String updateTime;
  
      //The data is encrypted before insert into the database, and be decrypted while load from database.
      @CustomType(AESEncryptedField.class)
      private String phoneNumber;
  
  	//the field value will be serialzed to a json String before insert into the database, and v.v.
      @CustomType(JSONObjectType.class)
      private CaAsset asserts;
  ```

* Providing Batch Insert, Batch Update, and Batch Delete operations. Supporting multiple sets of operation values through a single SQL statement to improve operation efficiency.
* Providing the @AutoGenerated annotation, which is used for the automatic maintenance of certain fields, such as recording creation time, update time, GUID, SnowFlake etc. data insertion. (This annotation is unrelated to any database-specific features such as Default value, triggers etc., and its implementation is purely on the Java side.)

  **Example:**

  ```java
  	@AutoGenerated(GeneratedType.UPDATED_TIMESTAMP,writeback = true)
  	private Date updated;
  ```

* Providing enhanced logging output. By using com.github.xuse.querydsl.sql.log.QueryDSLSQLListener, three types of logging output formats are available:
  **Example:**
  ```java
  /*
   *  FORMAT_COMPACT: The compact format suitable for large-scale production environment.
   *  FORMAT_FULL: Long strings will be fully outputted, and there will be line breaks between SQL and parameters.
   *  FORMAT_DEBUG: Detailed information is outputted with line breaks for easier reading, suitable for the development environment to observe statements and logic.
   */
    configuration.addListener(new QueryDSLSQLListener(QueryDSLSQLListener.FORMAT_DEBUG));
    configuration.setSlowSqlWarnMillis(200);
  ```
In production environment, it is recommended to use `FORMAT_COMPACT` for output. Displaying statements and parameters in a single line is beneficial for querying and analyzing using commands such as grep.

  * Outputting each SQL statement and its parameters, along with execution time and record count. If the log level is set to WARN, this part of the logic can be skipped to maximize performance.
  * Slow SQL statements are outputted at the Error level (the threshold for slow SQL can be set).
  * For Batch mode, parameters after every N groups are omitted for output. 

* Package scanning: Several annotation-based function enhancements have been introduced earlier in the text. Package scanning can analyze all database metamodels' definitions and verify the correctness of these annotations in advance when the application starts, registering some of the configurations to the global context. The @CustomType annotation needs to be scanned in advance to take effect.

* Additional annotations to define Metamodel(Query class): QueryDSL's native metamodel mainly uses APIs for definition which called in each Q class, and these codes always generated by a code generation process. The extension provides a set of annotation, which cover the original metamodel and extension functions.

  **Example**

  ```java
  @TableSpec(name="ca_asset",primaryKeyPath={"id"},collate = "utf8mb4_general_ci",
  keys = {
  		@Key(path= {"code"},type=ConstraintType.UNIQUE),
  		@Key(path= {"content"},type=ConstraintType.FULLTEXT),
  	}
  )
  @Comment("comments of this table.")
  public class CaAsset {
  	
  	@ColumnSpec(autoIncrement = true,type = Types.INTEGER,unsigned = true,nullable = false)
  	@Comment("primary key，auto increment.")
  	private int id;
  	
  	@ColumnSpec(type = Types.VARCHAR,size=64,nullable = false,defaultValue = "''")
  	@Comment("The code of asset. unique.")
  	private String code;
  	
  	@ColumnSpec(name="asset_name",size=128,nullable = false)
  	@Comment("The name of the asset.")
  	private String name;
  	
  	@ColumnSpec(size=16384)
  	@Comment("Asset's comments.")
  	private String content;
  ```

  Through the above example, the mapping method of fields in the database can be defined. Correspondingly, the code in the metamodel class can be omitted, but a line of code needs to be added to automatically scan the annotations:

  **Example**

  ```java
  public class QCaAsset extends RelationalPathBaseEx<CaAsset> {
  	public static final QCaAsset caAsset = new QCaAsset("foo");
  	
  	public final NumberPath<Integer> id = createNumber("id", int.class);
  
  	public final StringPath code = createString("code");
  	
  	public final StringPath name = createString("name");
  	
  	public final StringPath content = createString("content");
  
  	public QCaAsset(String variable) {
  		super(CaAsset.class, PathMetadataFactory.forVariable(variable), "null", "CA_ASSET");
  		super.scanClassMetadata();   //Note:This line of code enables the framework scan the annotations on the entity.
  	}
  ```



### Database access security

* Preventing some accidental operations: This is actually the normal usage of the official version of custom listener, which listens to SQL statements and blocks some dangerous operations. For example, the interceptor below can prevent Update or Delete operations executed against the entire table (without Where conditions).

  ```java
  configuration.addListener(new UpdateDeleteProtectListener());
  ```

* Preventing individual slow SQL statements from slowing down the entire database: You can set a global timeout for SQL requests. If the request exceeds the timeout, it will be automatically cancelled to prevent it from occupying database resources for a long time.

  ```java
  configuration.setDefaultQueryTimeout(5); //设置SQL最大执行时间为5秒
  ```


### Performance Optimization
Significant performance optimization has been carried out on QueryDSL-SQL. The optimized performance is comparable to well-written JDBC operations.
The following is a partial list. For more related data, please refer to the [Performance guide](static/performance_tunning.md)

**Performance Comparison Test (v5.0.0-r110)**

* MySQL 5.7.26
* MySQL JDBC Driver 5.1.49
* URL：postgresql://LAN_HOST:3306/test?useSSL=false
* jvm version=17

| Case                                                     | Mybatis 3.5.9（ms）                | querydsl-sql-extension<br /> 5.0.0-r110（ms） | A/B     |
| -------------------------------------------------------- | -------------------------------------- | ------------------------------------------------- | ------- |
| Insert 15 batches of 10,000 rows into a table with 7 columns.<br />Total of 150,000 records. | 7203, 7438, 7925<br />Avg.7522        | 2476, 2711, 2834<br /> Avg.2673.67                 | 281.34% |
| Insert 15 batches of 10,000 rows into a table with 22 columns.<br />Total of 150,000 records.  | 16939, 16870, 16782<br />Avg.16863.67 | 5541, 5609, 5538<br />Avg. 5562.67                | 303.16% |
| Retrieve 50 records from a table with 22 columns.       | 12, 14, 12<br />Avg. 12.667             | 8, 9, 10<br />Avg. 9                               | 140.7%  |
| Retrieve 5,000 records from a table with 22 columns.    | 646 , 601, 589<br />Avg. 612            | 79, 75, 82<br />Avg.78.67                         | 777.90% |
| Retrieve 50,000 records from a table with 22 columns.   | 935, 930, 953<br />Avg. 939.33          | 321, 323, 339<br />Avg. 327.67                     | 286.67% |
| Retrieve 300,000 records from a table with 22 columns   | 3340，3343, 3577<br />Avg. 3420        | 1832, 1925, 2313<br />Avg. 2023.33                | 169.03% |
| Retrieve 1,000,000 records from a table with 22 columns | 8478, 9219, 7468<br />Avg. 8388.33     | 6571, 7535, 5271<br />Avg. 6459                   | 129.87% |

Note:
* All tests were done in single-threaded mode. A simple calculation loop of about 500,000 iterations was run first to boost the CPU frequency.
* The log level was set to ERROR.
* Before timing the tests, the same SQL statements are executed once to ensure that the classes on the path are loaded in advance.
* The same environment, including the database, was used for all tests. The time difference between the two frameworks for the same set of tests should not exceed five minutes.
* Each test was run three times to calculate the average execution time (in milliseconds).
* MyBatis was configured fetchSize="5000" for SELECT, and QueryDSL was setFetchSize(5000) during query.


**The Secret of High Performance**
* **No-reflection Access:** The JavaBean-JDBC interaction part in QueryDSL has been rewritten to enhance performance. ASM is used to generate an accessor for each set of query fields corresponding to a Bean as an accelerated substitute for reflection.
The dynamic class generation scheme generates one accessor for each set of SELECT fields for an SQL query. The accessor is generated and loaded the first time the query is executed. The second time the SQL is executed, the performance is almost equivalent to hardcoding. Reflection and IF branches are eliminated during the process, and all accesses to ResultSet are in the order of indices (consider branch prediction by the CPU), significantly reducing the number of memory operations.

* **Table model and BeanCodec cache:** Cache for table and field models and the codec for each object.

* **Bytecode/JIT friendly:** Programming techniques based on principles such as minimizing memory copying, minimizing bytecode operation, JIT friendliness, and branch prediction. Techniques include stack manipulation, maximizing use of the final keyword, manual inlining, object reuse, one-time memory allocation, using tableswitch instead of complex branches, and more.

* **Tuning API for developers:** Provides fetchSize, maxRows, queryTimeout, and other methods that developers can use to tune performance and security when working with large amounts of data.

  **Example:** Retrieve 1 million IDs at once.
  ```java
  List<Integer> list = factory.select(t1.id).from(t1)
  		.setFetchSisze(10000)
  		.setMaxRows(1_000_000)
  		.setQueryTimeout(15)
  		.fetch();
  ```

**Compatibility**

* Utilizes dynamic class generation with ASM7, supporting JDK versions 8 through 22, and GraalVM (version 22).
* When using GraalVM native (AOT) mode, ASM class generation is ineffective, and Java code falls back to reflection-based type accessors, still ensuring normal functionality.
  (During GraalVM compilation, this part of the logic is essentially compiled into native static code, making ASM acceleration unnecessary.)

### R2dbc support
For R2dbc datasource

See module [querydsl-sql-r2dbc](querydsl-sql-r2dbc/) and [querydsl-sql-r2dbc With Spring Transactions](querydsl-sql-r2dbc-spring)。

### Other Functionality Enhancements

#### Database Structure Modeling

Database structure modeling: Extends QueryDSL's native `ColumnMetadata` to support describing all features of database tables in the Java (JDBC) model—including default value, unsigned, auto-increment, index, constraint (excluding foreign keys). The related model can be created through the metamodel API or defined via annotations.

  Q: What is the use of this feature?

  A: There are generally two ways database application developers work with data structures. One is to design the data structure in the database first and then generate the Java class structure using a Bean generation tool. This is known as database schema-first. 
  The other approach, often used by software developers developing applications across multiple RDBMSes, is to establish the Java Entity model first and then automatically create the database structure through the program. This is known as metadata-first. Typically, Hibernate supports automatically creating the database structure at startup; this framework also supports this usage.

QueryDSL's approach is database schema-first. This framework extends support for metadata-first scenarios, allowing Java metamodels to update the database structure in reverse. Additionally, the updates support incremental updates based on database structure comparison—allowing updates to indexes, constraints, views, and other table structures.

> Not supported: Foreign keys, materialized views, index-organized tables, custom functions, triggers, and stored procedures are not supported, as these features are rarely used in cross-RDBMS applications; hence, there is no need to support them at this time.

#### Pure POJO Usage (No QueryClass)

In the official version of QueryDSL, operating the database requires using a code generation tool to generate the query class. This framework enhances the original by allowing users to forego creating QueryClass classes and use pure POJOs with several annotations as a substitute query class model. Lambda expressions can be used to represent table or column models.

This feature is mainly to reduce the usage threshold. Refer to the document `static/USER_GUIDE.md`.

#### Multiple Styles of Low-code API

Some users have told me that the operation style of QueryDSL, like writing SQL statements with Java API, is very powerful, but for SQL beginners, they are more accustomed to a Repository that supports simple object operations, similar to tools like JPA, Hibernate, Mybatis Mapper.
Thus, some commonly used operations are encapsulated in the `GenericRepository` class to simplify daily CRUD operations for these low-code requirements.

#### Access and Modification of Database Structure (DDL)

* Supports querying information about schemas, tables, views, indexes, constraints, etc., via API.
* Supports common DDL operations such as Truncate, Create, Drop, Alter table, Partition, etc., using Java syntax.

#### Record Object mapping to database Relation

Since Java 16, the Record feature ( **@jls** 8.10 Record Types) has been supported. This framework allows using Record-type objects as table mappings, replacing traditional POJO entity Beans. For more details, see the document `user guide.md`.

> To use the Record feature, you must use JDK 16 or above.
> This framework has special handling for accessing Record objects, making it independent of JDK 16 or above. It can still run on Java 8 after being compiled.

### Runtime Environment and Scope of Application

**JDK**

* Open JDK / Oracle  JDK 8~22 
* Oracle GraalVM 17~22
* GraalVM Native (AOT)

**Databases (for DML)**

As same as the original Querydsl framework, Including these databases:

* MySQL v5.x ~ v8.x
* CUBRID
* DB2 10.1.2  and above
* Apache Derby 10.14  and above
* Firebird
* H2
* HSQLDB
* Oracle 10g  and above
* PostgreSQL 9.1 and above
* Teradata
* SQL Server 2005, 2008, 2012
* SQLite 

## Experimental Features

> Experimental features are new functionalities added based on specific use cases or suggestions, intended for user experience and feedback collection.

### Partition Management (Supported for MySQL and PostgreSQL)

> The example demonstrates functionality on MySQL.
> The partitioning mechanism of PostgreSQL is significantly different from MySQL. Currently, only partition table creation and partition addition/removal are supported. Due to the differences in database mechanisms, some features are not yet planned to be supported on PostgreSQL.

**Table of Supported Partition Features**

| Functions                | MySQL | PostgreSQL | Oracle   | Etc.. |
| -------------------- | ----- | ---------- | -------- | ----- |
| Create table with partitions | Yes   | Yes        | Planning |       |
| Query existing table partitions | Yes   | Yes        | Planning |       |
| Set a existing table to a partitioned table| Yes   | X          | Planning |       |
| Remove partition settings from a partitioned table   | Yes   | X          | Planning |       |
| create hash partitions       | Yes   | X          | Planning |       |
| create range partitions      | Yes   | Yes        | Planning |       |
| create list partitions       | Yes   | Yes        | Planning |       |
| Drop as partition           | Yes   | Yes        | Planning |       |
| Reorganization partitions    | Yes   | X          | Planning |       |
| Adjust partition count for hash partitions | Yes   | X          | Planning |       |


**Example**

```java
SQLMetadataQueryFactory metadata=factory.getMetadataFactory();
metadata.createTable(t1).reCreate().execute();

QPartitionFoo1 t1 = QPartitionFoo1.partitionFoo1;
//Create partitioning
metadata.createPartitioning(t1)
		.partitionBy(Partitions.byHash(HashType.HASH, "TO_DAYS(created)", 4))
		.execute();

//query existing partitions.
List<PartitionInfo> list=metadata.getPartitions(t1.getSchemaAndTable());

//remove partitioning, will not delete data in the table.
metadata.removePartitioning(t1).execute();

//Create partitions based on time ranges. If using MySQL, the start date can be unspecified.
metadata.createPartitioning(t1).partitionBy(
	Partitions.byRangeColumns(t1.created)
		.add("p202401", "'1970-12-01'","'2024-02-01'")
		.add("p202402", "'2024-02-01'","'2024-03-01'").build())
    .execute();

//Add a new partition to the above partitions.
//This operation will automatically use REORGANIZE PARTITION to move the data that meets the criteria from the originally first partition to the new partition
metadata.addParition(t1)
		.add("p20200101", "'2021-01-01'")
		.execute();

//Delete a partition (with the data within the partition)
metadata.dropPartition(t1)
    .partition("p20200101").execute();
```

### DDL Support

**Supported databases (For DDL)**

* MySQL v5.6 and above
* Apache Derby v10.14 and above
* PostgreSQL v10.3 and above
* H2 v2.3.232

For related instructions, refer to the quick_start.md document.

> Other databases can write their own SQLTemplatesEx (dialect extension class defined by this framework) for extension. If needed, you can also email me for discussions.


### MySQL Online DDL

Online DDL can prevent blocking caused by locks during DDL execution, which can affect user DML operations. Online DDL allows users to perform DML operations during the DDL process.

When executing DDL on MySQL databases, it automatically uses the Online method to minimize interference with production environment business access.
The example is as follows: when modifying a data table, the algorithm and lock are specified to ensure that DDL execution does not affect business operations.

Eg.

```sql
ALTER TABLE table1
  CHANGE c_bin c_bin BLOB NULL COMMENT 'test column', ALGORITHM = INPLACE, LOCK = NONE,
  DROP KEY idx_aaa_taskstatus, ALGORITHM = INPLACE, LOCK = NONE,
  ADD KEY idx_aaa_taskstatus (task_status), ALGORITHM = INPLACE, LOCK = SHARED
```

* The application of this feature does not mean that DDL execution has no impact on the data table. High-availability systems operating 24/7 should still execute DDL during business off-peak periods.
* Online DDL was introduced in MySQL 5.x, and more Online DDL strategies are supported in version 8.x. However, the dialects for versions 5.x and 8.x have not yet been distinguished, and a relatively conservative strategy has been adopted based on 5.x.

## FAQ
  Q: Regarding the impact of line breaks in SQL statements on log viewing.

  A:  use `com.querydsl.sql.SQLTemplates.Builder.newLineToSingleSpace()` method when creating SQLTemplate.

  Q: If my project already uses querydsl-sql, do I need to modify all the original query classes to inherit from the `com.github.xuse.querydsl.sql.RelationalPathBaseEx` class when integrating this framework?

  A: No, you don't have to. This framework makes some minor adjustments and improvements on querydsl, without affecting the native usage of querydsl.