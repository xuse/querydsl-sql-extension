package com.github.xuse.querydsl.sql.expression;

import java.util.List;
import java.util.UUID;

import com.github.xuse.querydsl.annotation.AutoGenerated;
import com.github.xuse.querydsl.config.SnowflakeIdManager;
import com.github.xuse.querydsl.sql.column.ColumnMapping;
import com.github.xuse.querydsl.util.Entry;
import com.github.xuse.querydsl.util.Exceptions;
import com.github.xuse.querydsl.util.SnowflakeIdWorker;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.Path;
import com.querydsl.core.types.dsl.Expressions;
import com.querydsl.core.types.dsl.NumberPath;
import com.querydsl.sql.PrimaryKey;
import com.querydsl.sql.RelationalPath;

public abstract class AbstractMapperSupport {

	public static final int SCENARIO_NORMAL = 0;
	public static final int SCENARIO_INSERT = 1;
	public static final int SCENARIO_UPDATE = 2;
	
	public static boolean isUnsavedValue(ColumnMapping columnMetadata, Object value) {
		if (value instanceof Expression<?>) {
			return false;
		}
		return columnMetadata.isUnsavedValue(value);
	}

	/*
	 * Nullable columnMapping
	 */
	protected void processNullBindings(Path<?> p, List<Entry<Path<?>, Object>> data, ColumnMapping columnMapping) {
	}

	protected static boolean isKeyColumn(Path<?> path) {
		Path<?> parent = path.getMetadata().getParent();
		// 计算列是不是主键字段，如果是主键字段那么为null时，也不尝试更新。因为数据库主键天然的不允许为NULL。
		if (parent instanceof RelationalPath) {
			PrimaryKey<?> pk = ((RelationalPath<?>) parent).getPrimaryKey();
			return pk != null && pk.getLocalColumns().contains(path);
		}
		return false;
	}

	// 根据自动生成值注解返回要写入的自动数据
	/**
	 * @param generateDef generateDef
	 * @param metadata    可能为NULL。当用户使用非默认的bean进行数据库操作时，该字段可能为null
	 * @param scenario scenario
	 * @return Object
	 */
	public static Object asAutoValue(AutoGenerated generateDef, ColumnMapping metadata, int scenario) {
		switch(generateDef.value()) {
			case CREATED_TIMESTAMP:
				if (scenario == SCENARIO_INSERT) {
					return Expressions.currentTimestamp();
				}
				break;
			case UPDATED_TIMESTAMP:
				if (scenario > 0) {
					return Expressions.currentTimestamp();
				}
				break;
			case GUID36:
				if (scenario == SCENARIO_INSERT) {
					UUID uuid = UUID.randomUUID();
					return uuid.toString();
				}
				break;
			case GUID32:
				if (scenario == SCENARIO_INSERT) {
					UUID uuid = UUID.randomUUID();
					return uuid2String32(uuid.getMostSignificantBits(), uuid.getLeastSignificantBits());
				}
				break;
			case VERSION:
				if (scenario == SCENARIO_INSERT) {
					Class<?> type= metadata.getType();
					if(type==Long.class || type==Long.TYPE) {
						return 1L;
					}else {
						return 1;
					}
				}else if(scenario==SCENARIO_UPDATE){
					Path<?> path= metadata.getPath();
					if(path instanceof NumberPath) {
						return ((NumberPath<?>)path).add(Expressions.ONE);
					}else {
						throw Exceptions.illegalArgument("A 'Version' field must be defined as a NumberPath. field={}", metadata.getColumn());
					}
				}
			case SNOWFLAKE:
				if (scenario == SCENARIO_INSERT) {
					SnowflakeIdWorker worker;
					if ((worker = SnowflakeIdManager.getInstance()) != null) {
						return worker.nextId();
					} else {
						throw Exceptions.illegalArgument("Please init snowflake workerId and datacenterId for @AutoGenerated type 'SNOWFLAKE'!");
					}
				}
				break;
			default:
				throw new IllegalArgumentException("Unsupported auto-generate type:" + generateDef.value());
		}
		return null;
	}

	private static String uuid2String32(long mostSigBits, long leastSigBits) {
		return (digits(mostSigBits >> 32, 8) + digits(mostSigBits >> 16, 4) + digits(mostSigBits, 4) + digits(leastSigBits >> 48, 4) + digits(leastSigBits, 12));
	}

	private static String digits(long val, int digits) {
		long hi = 1L << (digits * 4);
		return Long.toHexString(hi | (val & (hi - 1))).substring(1);
	}
}
