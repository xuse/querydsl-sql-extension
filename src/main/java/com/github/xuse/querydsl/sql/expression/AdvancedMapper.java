package com.github.xuse.querydsl.sql.expression;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.github.xuse.querydsl.annotation.AutoGenerated;
import com.github.xuse.querydsl.annotation.UnsavedValue;
import com.github.xuse.querydsl.config.ConfigurationEx;
import com.github.xuse.querydsl.sql.RelationalPathEx;
import com.github.xuse.querydsl.sql.column.ColumnMapping;
import com.github.xuse.querydsl.sql.column.UnsavedValuePredicateFactory;
import com.github.xuse.querydsl.util.Entry;
import com.github.xuse.querydsl.util.Exceptions;
import com.github.xuse.querydsl.util.collection.ArrayListMap;
import com.querydsl.core.QueryException;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.Path;
import com.querydsl.core.types.dsl.Expressions;
import com.querydsl.core.util.ReflectionUtils;
import com.querydsl.sql.PrimaryKey;
import com.querydsl.sql.RelationalPath;
import com.querydsl.sql.dml.Mapper;

/**
 * A Mapper that using dynamic codec class to extract values from the entity-bean.
 * 
 * @see Mapper
 * 
 * @author Joey
 */
public class AdvancedMapper {
	/**
	 * Singleton instance
	 * 空值绑定会被跳过，因此在Batch模式下根据参数中的空值不同，很容易生成多组SQL语句。
	 * 当多组SQL执行executeWithKey时，会抛出异常，因此执行批量插入并且获取Key时，不能使用这种Mapper。
	 */
	public static AdvancedMapper INSTANCE = new AdvancedMapper(0);
	
	/**
	 * 空值绑定会向Statement中执行setNull(index, sqlType). 适合于批量模式下统一SQL语句。
	 * 但是对于带有自生成如自增键、缺省值等字段，尝试写入NULL可能导致异常。
	 */
	public static AdvancedMapper INSTANCE_NULLS_BINGIND = ofNullsBingding(0);
	
	
	private int scenario;
	
	public static final int SCENARIO_INSERT = 1;

	public static final int SCENARIO_UPDATE = 2;
	
	/**
	 * 非主键字段，将会在值的Map中写入Null值。
	 * 简单来说，即是Null is null.
	 * 默认情况下，Null is "do not tell database. using default"
	 * @param scenario
	 * @return AdvancedMapper
	 */
	public static final AdvancedMapper ofNullsBingding(int scenario) {
		return new AdvancedMapper(scenario) {
			protected void processNullBindings(Path<?> path,List<Entry<Path<?>, Object>> data,ColumnMapping metadata) {
				if(!isKeyColumn(path)){
					data.add(new Entry<>(path, com.querydsl.sql.types.Null.DEFAULT));	
				}
			}
		};
	}
	
	protected static boolean isKeyColumn(Path<?> path) {
		Path<?> parent=path.getMetadata().getParent();
		//计算列是不是主键字段，如果是主键字段那么为null时，也不尝试更新。因为数据库主键天然的不允许为NULL。
		if(parent instanceof RelationalPath) {
			PrimaryKey<?> pk=((RelationalPath<?>) parent).getPrimaryKey();
			return pk.getLocalColumns().contains(path);
		}
		return false;
	}

	/**
	 * 直接在SQL语句的Value区域写入DEFAULT关键字。在某些数据库上有用。
	 * 简单来说，即是Null is DEFAULT.
	 * @param scenario
	 * @return AdvancedMapper
	 */	
	public static final AdvancedMapper ofNullsAsDefaultBingding(int scenario) {
		return new AdvancedMapper(scenario) {
			protected void processNullBindings(Path<?> path,List<Entry<Path<?>, Object>> data,ColumnMapping metadata) {
				if(isKeyColumn(path)){
					return;	
				}
				if(metadata!=null && metadata.getDefaultExpression()!=null) {
					//set use the database default.
					data.add(new Entry<>(path, Expressions.template(path.getType(), "DEFAULT")));		
				}else {
					//set as null
					data.add(new Entry<>(path, com.querydsl.sql.types.Null.DEFAULT));
				}
			}
		};
	}
	
	public AdvancedMapper(int scenario) {
		this.scenario=scenario;
	}
	
	@SuppressWarnings("rawtypes")
	public Map<Path<?>, Object> createMap(RelationalPath<?> entity, Object bean, ConfigurationEx config) {
		if (entity instanceof RelationalPathEx && entity.getType().isAssignableFrom(bean.getClass())) {
			return createMapOptimized((RelationalPathEx) entity, bean,config);
		} else {
			return createMap0(entity, bean,config);
		}
	}

	/**
	 * Create the property map using ASM generated class.
	 * @param entity
	 * @param bean
	 * @return 映射路径对象
	 */
	@SuppressWarnings({"rawtypes","unchecked"}) 
	private Map<Path<?>, Object> createMapOptimized(RelationalPathEx entity, Object bean, ConfigurationEx config) {
		List<Path<?>> path = entity.getColumns();
		BeanCodec bc = entity.getBeanCodec();
		Object[] values = bc.values(bean);
		int len = path.size();
		List<Entry<Path<?>, Object>> data = new ArrayList<>(len);
		for (int i = 0; i < len; i++) {
			Object value = values[i];
			Path<?> p=path.get(i);
			ColumnMapping metadata=entity.getColumnMetadata(p);
			if((scenario == SCENARIO_UPDATE && metadata.isNotUpdate()) || (scenario==SCENARIO_INSERT && metadata.isNotInsert())) {
				continue;
			}
			boolean nullValue=isUnsavedValue(metadata, value);
			// 如果具有自动生成类型
			AutoGenerated generated;
			if ((generated=metadata.getGenerated())!= null && (generated.overwrite() || nullValue)) {
				Object autoValue = asAutoValue(generated, metadata, scenario, config);
				if (autoValue != null) {
					value = autoValue;
					nullValue = false;
					if(generated.writeback()) {
						metadata.writeback(bean,value);
					}
				}
			}	
			if (nullValue) {
				processNullBindings(p,data,metadata);
			} else{
				//处理空值是否绑定
				data.add(new Entry<>(p, value));
			}
		}
		return ArrayListMap.wrap(data);
	}
	
	//根据自动生成值注解返回要写入的自动数据
	/**
	 * @param generateDef
	 * @param metadata 可能为NULL。当用户使用非默认的bean进行数据库操作时，该字段可能为null
	 * @param scenario
	 * @param config
	 * @return Object
	 */
	public static Object asAutoValue(AutoGenerated generateDef, ColumnMapping metadata,int scenario, ConfigurationEx config) {
		switch(generateDef.value()) {
		case CREATED_TIMESTAMP:
			if(scenario==SCENARIO_INSERT){
				return Expressions.currentTimestamp();
			}
			break;
		case UPDATED_TIMESTAMP:
			if(scenario>0){
				return Expressions.currentTimestamp();
			}
			break;
		case GUID36:
			if(scenario==SCENARIO_INSERT){
				UUID uuid = UUID.randomUUID();
				return uuid.toString();
			}
			break;
		case GUID32:
			if(scenario==SCENARIO_INSERT){
				UUID uuid = UUID.randomUUID();
				return uuid2String32(uuid.getMostSignificantBits(),uuid.getLeastSignificantBits());
			}
			break;
		case SNOWFLAKE:
			if(scenario==SCENARIO_INSERT){
				if(config.getSnowflakeWorker()!=null){
					return config.getSnowflakeWorker().nextId();
				}else {
					throw Exceptions.illegalArgument("Please init snowflake workerId and datacenterId for @AutoGenerated type 'SNOWFLAKE'!");
				}
			}
			break;
		default:
			throw new IllegalArgumentException("Unsupported auto-generate type:"+generateDef.value());
		}
		return null;
	}

	private static String uuid2String32(long mostSigBits, long leastSigBits) {
		return (digits(mostSigBits >> 32, 8) +  digits(mostSigBits >> 16, 4) + digits(mostSigBits, 4) 
				+ digits(leastSigBits >> 48, 4) + digits(leastSigBits, 12));
	}

	private static String digits(long val, int digits) {
		long hi = 1L << (digits * 4);
		return Long.toHexString(hi | (val & (hi - 1))).substring(1);
	}
	    
	/*
	 * @Nullable  columnMapping
	 */
	protected void processNullBindings(Path<?> p, List<Entry<Path<?>, Object>> data, ColumnMapping columnMapping) {
	}
//	protected void processNullBindings(Path<?> path,RelationalPath<?> entity,List<Entry<Path<?>, Object>> data) {
//	}

	private Map<Path<?>, Object> createMap0(RelationalPath<?> entity, Object bean, ConfigurationEx config) {
		try {
			Class<?> beanClass = bean.getClass();
			Map<String, Path<?>> columns = getColumns(entity);
			List<Entry<Path<?>, Object>> data = new ArrayList<>(columns.size());
			for (Map.Entry<String, Path<?>> entry : columns.entrySet()) {
				Path<?> path = entry.getValue();
				//性能比较差
				Field beanField = ReflectionUtils.getFieldOrNull(beanClass, entry.getKey());
				if (beanField != null && !Modifier.isStatic(beanField.getModifiers())) {
					beanField.setAccessible(true);
					Object value = beanField.get(bean);
					boolean nullValue = isNullValue(beanField, value);
					AutoGenerated anno = beanField.getAnnotation(AutoGenerated.class);
					if (anno != null && (nullValue || anno.overwrite())) {
						Object newValue = asAutoValue(anno, null, scenario, config);
						if (newValue != null) {
							value = newValue;
							nullValue = false;
						}
					}
					if (!nullValue) {
						data.add(new Entry<>(path, value));
					} else {
						processNullBindings(path,data,null);
					}
				}
			}
			return ArrayListMap.wrap(data);
		} catch (IllegalAccessException e) {
			throw new QueryException(e);
		}
	}



	private boolean isNullValue(Field field, Object propertyValue) {
		UnsavedValue anno= field.getAnnotation(UnsavedValue.class);
		return UnsavedValuePredicateFactory.create(field.getType(),anno==null?null:anno.value()).test(propertyValue);
	}
	
	public static boolean isUnsavedValue(ColumnMapping columnMetadata, Object value) {
        if (value instanceof Expression<?>) {
        	return false;
        }
		return columnMetadata.isUnsavedValue(value);
	}

	protected Map<String, Path<?>> getColumns(RelationalPath<?> path) {
		Map<String, Path<?>> columns = new LinkedHashMap<>();
		for (Path<?> column : path.getColumns()) {
			columns.put(column.getMetadata().getName(), column);
		}
		return columns;
	}
}
