/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.xuse.querydsl.sql.dml;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import com.github.xuse.querydsl.config.ConfigurationEx;
import com.github.xuse.querydsl.sql.Mappers;
import com.github.xuse.querydsl.sql.RelationalPathEx;
import com.github.xuse.querydsl.sql.SQLBindingsAlter;
import com.github.xuse.querydsl.sql.column.ColumnMapping;
import com.github.xuse.querydsl.sql.expression.AdvancedMapper;
import com.github.xuse.querydsl.sql.log.ContextKeyConstants;
import com.github.xuse.querydsl.sql.routing.RoutingStrategy;
import com.github.xuse.querydsl.util.Exceptions;
import com.querydsl.core.QueryMetadata;
import com.querydsl.core.Tuple;
import com.querydsl.core.types.ConstantImpl;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.ParamExpression;
import com.querydsl.core.types.ParamNotSetException;
import com.querydsl.core.types.Path;
import com.querydsl.core.util.ResultSetAdapter;
import com.querydsl.sql.ColumnMetadata;
import com.querydsl.sql.RelationalPath;
import com.querydsl.sql.SQLListenerContextImpl;
import com.querydsl.sql.SQLQuery;
import com.querydsl.sql.SQLSerializer;
import com.querydsl.sql.SQLSerializerAlter;
import com.querydsl.sql.SQLTemplates;
import com.querydsl.sql.dml.AbstractSQLInsertClause;
import com.querydsl.sql.dml.Mapper;
import com.querydsl.sql.dml.SQLInsertBatch;
import lombok.extern.slf4j.Slf4j;

/**
 * SQLInsertClause defines an INSERT INTO clause If you need to subtype this,
 * use {@link AbstractSQLInsertClause} instead.
 *
 * @author tiwe
 */
@Slf4j
public class SQLInsertClauseAlter extends AbstractSQLInsertClause<SQLInsertClauseAlter> {

	private final ConfigurationEx configuration;

	private RoutingStrategy routing;
	
	private boolean writeNulls = false;

	public SQLInsertClauseAlter(Connection connection, SQLTemplates templates, RelationalPath<?> entity) {
		this(connection, new ConfigurationEx(templates), entity);
	}

	public SQLInsertClauseAlter(Connection connection, SQLTemplates templates, RelationalPath<?> entity, SQLQuery<?> subQuery) {
		this(connection, new ConfigurationEx(templates), entity, subQuery);
	}

	public SQLInsertClauseAlter(Connection connection, ConfigurationEx configuration, RelationalPath<?> entity, SQLQuery<?> subQuery) {
		super(connection, configuration.get(), entity, subQuery);
		this.configuration = configuration;
	}

	public SQLInsertClauseAlter(Connection connection, ConfigurationEx configuration, RelationalPath<?> entity) {
		super(connection, configuration.get(), entity);
		this.configuration = configuration;
	}

	public SQLInsertClauseAlter(Supplier<Connection> connection, ConfigurationEx configuration, RelationalPath<?> entity, SQLQuery<?> subQuery) {
		super(connection, configuration.get(), entity, subQuery);
		this.configuration = configuration;
	}

	public SQLInsertClauseAlter(Supplier<Connection> connection, ConfigurationEx configuration, RelationalPath<?> entity) {
		super(connection, configuration.get(), entity);
		this.configuration = configuration;
	}

	/**
	 * Add fields with automatically generated values
	 * <p>
	 * 添加自动生成值的字段
	 * @return SQLInsertClauseAlter
	 */
	public SQLInsertClauseAlter populateAutoGeneratedColumns() {
		RelationalPathEx<?> entity = (RelationalPathEx<?>) this.entity;
		List<Path<?>> paths = entity.getColumns();
		for (Path<?> p : paths) {
			ColumnMapping metadata = entity.getColumnMetadata(p);
			// 用户没有显式设置过值时才会填充字段
			if (metadata.getGenerated() == null) {
				continue;
			}
			if (columns.contains(p)) {
				continue;
			}
			Object value = AdvancedMapper.asAutoValue(metadata.getGenerated(), metadata, Mappers.SCENARIO_INSERT);
			if (value instanceof Expression<?>) {
				columns.add(p);
				values.add((Expression<?>) value);
			} else if (!metadata.isUnsavedValue(value)) {
				columns.add(p);
				assert value != null;
				values.add(ConstantImpl.create(value));
			}
		}
		return this;
	}

	/**
	 *  Execute the clause and return the generated keys as a ResultSet
	 *<p>
	 * 执行该子句并将生成的键作为 ResultSet 返回。
	 *  @return result set with generated keys
	 */
	public ResultSet executeWithKeys() {
		context = startContext(connection(), metadata, entity);
		try {
			PreparedStatement stmt;
			if (batches.isEmpty()) {
				stmt = createStatement(true);
				listeners.notifyInsert(entity, metadata, columns, values, subQuery);
				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
			} else if (batchToBulk) {
				stmt = createStatement(true);
				listeners.notifyInserts(entity, metadata, batches);
				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
			} else {
				Collection<PreparedStatement> stmts = createStatements(true);
				if (stmts.size() > 1) {
					throw new IllegalStateException("executeWithKeys called with batch statement and multiple SQL strings");
				}
				stmt = stmts.iterator().next();
				listeners.notifyInserts(entity, metadata, batches);
				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int[] rc = stmt.executeBatch();
				long count = 0;
				for (int r : rc) {
					count = count + r;
				}
				postExecuted(context, System.currentTimeMillis() - start, "BatchInsert", count);
			}
			final Statement stmt2 = stmt;
			ResultSet rs = stmt.getGeneratedKeys();
			return new ResultSetAdapter(rs) {

				@Override
				public void close() throws SQLException {
					try {
						super.close();
					} finally {
						stmt2.close();
						reset();
						endContext(context);
					}
				}
			};
		} catch (SQLException e) {
			onException(context, e);
			reset();
			endContext(context);
			throw configuration.translate(queryString, constants, e);
		}
	}

	@Override
	public long execute() {
		context = startContext(connection(), metadata, entity);
		PreparedStatement stmt = null;
		Collection<PreparedStatement> stmts = null;
		try {
			if (batches.isEmpty()) {
				// 没有任何数据需要插入
				if (populatedEmptyBatch && columns.isEmpty()) {
					return 0;
				}
				stmt = createStatement(false);
				listeners.notifyInsert(entity, metadata, columns, values, subQuery);
				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
				return rc;
			} else if (batchToBulk) {
				stmt = createStatement(false);
				listeners.notifyInserts(entity, metadata, batches);
				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
				return rc;
			} else {
				stmts = createStatements(false);
				listeners.notifyInserts(entity, metadata, batches);
				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				long rc = executeBatch(stmts);
				postExecuted(context, System.currentTimeMillis() - start, "BatchInsert", rc);
				return rc;
			}
		} catch (SQLException e) {
			onException(context, e);
			throw configuration.translate(queryString, constants, e);
		} finally {
			if (stmt != null) {
				close(stmt);
			}
			if (stmts != null) {
				close(stmts);
			}
			reset();
			endContext(context);
		}
	}

	/**
	 *  Set the data for bulk insertion
	 *  <p>
	 *  设置要批量插入的数据
	 *
	 *  @implSpec
	 *  使用带NULLBinding的方式设置变量，批量装配时，无论是否为null值，都会在SQL中显示声明，因此数据库的默认值将无效
	 *  @param beans data to insert
	 *  @return this SQLInsertClauseAlter
	 */
	public SQLInsertClauseAlter populateBatch(Collection<?> beans) {
		populateBatch0(beans, Mappers.get(Mappers.SCENARIO_INSERT_NULL_WITH_DEFAULT | Mappers.NULLS_BIND | Mappers.TYPE_BEAN));
		return this;
	}

	/**
	 * Set the data for bulk insertion
	 * <p>
	 * 设置要批量插入的数据
	 *
	 * @param beans data to insert
	 * @param mapper the mapper object.
	 * @return this SQLInsertClauseAlter
	 * @see AdvancedMapper
	 * @param <T> The type of target object.
	 */
	public <T> SQLInsertClauseAlter populateBatch(Collection<T> beans, Mapper<T> mapper) {
		populateBatch0(beans, mapper);
		return this;
	}

	/**
	 * Set the data for bulk insertion (Tuple objects)
	 * <p>
	 * 设置要批量插入的动态数据（用Tuple类型表示）
	 * @param beans 数据
	 * @return this
	 */
	public SQLInsertClauseAlter populateTuples(Collection<Tuple> beans) {
		populateBatch0(beans, Mappers.get(Mappers.SCENARIO_INSERT | Mappers.NULLS_BIND | Mappers.TYPE_TUPLE));
		return this;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private void populateBatch0(Collection beans, Mapper mapper) {
		if (beans == null || beans.isEmpty()) {
			populatedEmptyBatch = true;
			return;
		}
		for (Object obj : beans) {
			Map<Path<?>, Object> values = mapper.createMap(entity, obj);
			for (Map.Entry<Path<?>, Object> entry : values.entrySet()) {
				set((Path) entry.getKey(), entry.getValue());
			}
			addBatch();
		}
	}

	private transient boolean populatedEmptyBatch;

	/**
	 * {@inheritDoc}
	 */
	@SuppressWarnings("unchecked")
	public SQLInsertClauseAlter populate(Object bean) {
		int type=Mappers.SCENARIO_INSERT | Mappers.TYPE_BEAN;
		if(writeNulls) {
			type = type | Mappers.NULLS_BIND;
		}
		return populate(bean, Mappers.get(type));
	}

	/**
	 * Populate the INSERT clause with the properties of the given bean.
	 * Theproperties need to match the fields of the clause's entity instance.
	 * <p>
	 * 使用定 bean 的属性填充 INSERT 子句。这些属性需要与子句的实体实例的字段匹配。
	 * 
	 * @param bean bean to use for population
	 * @return the current object
	 */
	@SuppressWarnings("unchecked")
	public SQLInsertClauseAlter populate(Tuple bean) {
		int type=Mappers.SCENARIO_INSERT | Mappers.TYPE_TUPLE;
		if(writeNulls) {
			type = type | Mappers.NULLS_BIND;
		}
		return populate(bean, Mappers.get(type));
	}

	protected Collection<PreparedStatement> createStatements(boolean withKeys) throws SQLException {
		boolean addBatches = !super.configuration.getUseLiterals();
		listeners.preRender(context);
		if (subQueryBuilder != null) {
			subQuery = subQueryBuilder.select(values.toArray(new Expression[0])).clone();
			values.clear();
		}
		Map<String, PreparedStatement> stmts = new HashMap<>();
		// add first batch
		{
			SQLSerializerAlter serializer = new SQLSerializerAlter(configuration, true);
			serializer.setUseLiterals(useLiterals);
			serializer.setRouting(routing);
			SQLInsertBatch batch = batches.get(0);
			serializer.serializeInsert(metadata, entity, batch.getColumns(), batch.getValues(), batch.getSubQuery());
			String sql = serializer.toString();
			PreparedStatement stmt = prepareStatementAndSetParameters(new SQLBindingsAlter(sql, serializer.getConstants(), serializer.getConstantPaths()), withKeys);
			if (addBatches) {
				stmt.addBatch();
			}
			stmts.put(sql, stmt);
			context.addSQL(createBindings(metadata, serializer));
			listeners.rendered(context);
		}
		// add other batches
		int maxLoginBatch = configuration.getMaxRecordsLogInBatch();
		for (int i = 1; i < batches.size(); i++) {
			SQLInsertBatch batch = batches.get(i);
			listeners.preRender(context);
			SQLSerializerAlter serializer = new SQLSerializerAlter(configuration, true);
			serializer.setUseLiterals(useLiterals);
			serializer.setRouting(routing);
			serializer.serializeInsert(metadata, entity, batch.getColumns(), batch.getValues(), batch.getSubQuery());
			String sql = serializer.toString();
			if (i <= maxLoginBatch) {
				context.addSQL(createBindings(metadata, serializer));
				listeners.rendered(context);
			}
			PreparedStatement stmt = stmts.get(serializer.toString());
			if (stmt == null) {
				stmt = prepareStatementAndSetParameters(new SQLBindingsAlter(sql, serializer.getConstants(), serializer.getConstantPaths()), withKeys);
				stmts.put(serializer.toString(), stmt);
			} else {
				setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(), metadata.getParams());
			}
			if (addBatches) {
				stmt.addBatch();
			}
		}
		if (stmts.size() > 1) {
			log.warn("There are multi sqls in this batch.{}", stmts.keySet());
		}
		return stmts.values();
	}

	protected PreparedStatement createStatement(boolean withKeys) throws SQLException {
		listeners.preRender(context);
		SQLSerializerAlter serializer = new SQLSerializerAlter(configuration, true);
		serializer.setUseLiterals(useLiterals);
		serializer.setRouting(routing);
		if (subQueryBuilder != null) {
			subQuery = subQueryBuilder.select(values.toArray(new Expression[values.size()])).clone();
			values.clear();
		}
		if (!batches.isEmpty() && batchToBulk) {
			serializer.serializeInsert(metadata, entity, batches);
		} else {
			serializer.serializeInsert(metadata, entity, columns, values, subQuery);
		}
		SQLBindingsAlter bindings = createBindings(metadata, serializer);
		context.addSQL(bindings);
		listeners.rendered(context);
		return prepareStatementAndSetParameters(serializer, withKeys);
	}

	protected PreparedStatement prepareStatementAndSetParameters(SQLBindingsAlter bindings, boolean withKeys) throws SQLException {
		listeners.prePrepare(context);
		this.queryString = bindings.getSQL();
		this.constants = bindings.getNullFriendlyBindings();
		PreparedStatement stmt;
		if (withKeys) {
			if (entity.getPrimaryKey() != null) {
				String[] target = new String[entity.getPrimaryKey().getLocalColumns().size()];
				for (int i = 0; i < target.length; i++) {
					Path<?> path = entity.getPrimaryKey().getLocalColumns().get(i);
					String column = ColumnMetadata.getName(path);
					column = configuration.getColumnOverride(entity.getSchemaAndTable(), column);
					target[i] = column;
				}
				stmt = connection().prepareStatement(queryString, target);
			} else {
				stmt = connection().prepareStatement(queryString, Statement.RETURN_GENERATED_KEYS);
			}
		} else {
			stmt = connection().prepareStatement(queryString);
		}
		setParameters(stmt, constants, bindings.getPaths(), metadata.getParams());
		context.addPreparedStatement(stmt);
		listeners.prepared(context);
		return stmt;
	}

	protected void setParameters(PreparedStatement stmt, List<?> objects, List<Path<?>> constantPaths, Map<ParamExpression<?>, ?> params) {
		if (objects.size() != constantPaths.size()) {
			throw new IllegalArgumentException("Expected " + objects.size() + " paths, " + "but got " + constantPaths.size());
		}
		for (int i = 0; i < objects.size(); i++) {
			Object o = objects.get(i);
			try {
				if (o instanceof ParamExpression) {
					if (!params.containsKey(o)) {
						throw new ParamNotSetException((ParamExpression<?>) o);
					}
					o = params.get(o);
				}
				super.configuration.set(stmt, constantPaths.get(i), i + 1, o);
			} catch (SQLException e) {
				Path<?> p = constantPaths == null ? null : constantPaths.get(i);
				log.error(queryString + "\nField " + i + " path=" + p + " set error. " + e.getMessage());
				throw super.configuration.translate(e);
			}
		}
	}

	@Override
	protected SQLBindingsAlter createBindings(QueryMetadata metadata, SQLSerializer serializer) {
		String queryString = serializer.toString();
		List<Object> args = new ArrayList<>();
		Map<ParamExpression<?>, Object> params = metadata.getParams();
		for (Object o : serializer.getConstants()) {
			if (o instanceof ParamExpression) {
				if (!params.containsKey(o)) {
					throw new ParamNotSetException((ParamExpression<?>) o);
				}
				o = metadata.getParams().get(o);
			}
			args.add(o);
		}
		return new SQLBindingsAlter(queryString, args, serializer.getConstantPaths());
	}

	private void postExecuted(SQLListenerContextImpl context, long cost, String action, long count) {
		context.setData(ContextKeyConstants.ELAPSED_TIME, cost);
		context.setData(ContextKeyConstants.COUNT, count);
		context.setData(ContextKeyConstants.ACTION, action);
		if (this.configuration.getSlowSqlWarnMillis() <= cost) {
			context.setData(ContextKeyConstants.SLOW_SQL, Boolean.TRUE);
		}
		listeners.executed(context);
	}

	public SQLInsertClauseAlter withRouting(RoutingStrategy routing) {
		this.routing = routing;
		return this;
	}
	
	/**
	 *  By default, null values in the bean will not write to the database. After call this method, the population method such as {@link #populate(Object)}
	 *  will allow the system to attempt to update null values to the database.
	 *
	 *  <h2>中文</h2>
	 *  默认不会写入Bean中null数值。开启后会尝试更新null值到数据库中。
	 *  @param flag true to enable the update null values feature.
	 *  @return SQLUpdateClauseAlter
	 */
	public SQLInsertClauseAlter writeNulls(boolean flag) {
		if(!columns.isEmpty()) {
			throw Exceptions.illegalState("This method should be called before method 'populate'.");
		}
		this.writeNulls = flag;
		return this;
	}
}
