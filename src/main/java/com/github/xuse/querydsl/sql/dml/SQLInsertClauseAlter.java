/*
 * Copyright 2015, The Querydsl Team (http://www.querydsl.com/team)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.xuse.querydsl.sql.dml;


import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

import com.github.xuse.querydsl.config.ConfigurationEx;
import com.github.xuse.querydsl.sql.RelationalPathEx;
import com.github.xuse.querydsl.sql.SQLBindingsAlter;
import com.github.xuse.querydsl.sql.column.ColumnMapping;
import com.github.xuse.querydsl.sql.expression.AdvancedMapper;
import com.github.xuse.querydsl.sql.expression.TupleMapper;
import com.github.xuse.querydsl.sql.log.ContextKeyConstants;
import com.querydsl.core.QueryMetadata;
import com.querydsl.core.Tuple;
import com.querydsl.core.types.ConstantImpl;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.ParamExpression;
import com.querydsl.core.types.ParamNotSetException;
import com.querydsl.core.types.Path;
import com.querydsl.core.util.ResultSetAdapter;
import com.querydsl.sql.ColumnMetadata;
import com.querydsl.sql.RelationalPath;
import com.querydsl.sql.RoutingStrategy;
import com.querydsl.sql.SQLListenerContextImpl;
import com.querydsl.sql.SQLQuery;
import com.querydsl.sql.SQLSerializer;
import com.querydsl.sql.SQLSerializerAlter;
import com.querydsl.sql.SQLTemplates;
import com.querydsl.sql.dml.AbstractSQLInsertClause;
import com.querydsl.sql.dml.Mapper;
import com.querydsl.sql.dml.SQLInsertBatch;

import lombok.extern.slf4j.Slf4j;

/**
 * SQLInsertClause defines an INSERT INTO clause If you need to subtype this,
 * use {@link AbstractSQLInsertClause} instead.
 *
 * @author tiwe
 *
 */
@Slf4j
public class SQLInsertClauseAlter extends AbstractSQLInsertClause<SQLInsertClauseAlter>  {

	private static final AdvancedMapper FOR_INSERT = new AdvancedMapper(AdvancedMapper.SCENARIO_INSERT);
	
	private static final AdvancedMapper FOR_BATCHINSERT = AdvancedMapper.ofNullsAsDefaultBinding(AdvancedMapper.SCENARIO_INSERT);

	private static final TupleMapper FOR_TUPLE_INSERT = new TupleMapper(AdvancedMapper.SCENARIO_INSERT);

	private static final TupleMapper FOR_TUPLE_BATCHINSERT = TupleMapper.ofNullsAsDefaultBingding(AdvancedMapper.SCENARIO_INSERT);
	
	private final ConfigurationEx configEx;
	private RoutingStrategy routing;
	
	public SQLInsertClauseAlter(Connection connection, SQLTemplates templates, RelationalPath<?> entity) {
		this(connection, new ConfigurationEx(templates), entity);
	}

	public SQLInsertClauseAlter(Connection connection, SQLTemplates templates, RelationalPath<?> entity, SQLQuery<?> subQuery) {
		this(connection, new ConfigurationEx(templates), entity, subQuery);
	}

	public SQLInsertClauseAlter(Connection connection, ConfigurationEx configuration, RelationalPath<?> entity, SQLQuery<?> subQuery) {
		super(connection, configuration.get(), entity, subQuery);
		this.configEx=configuration;
	}

	public SQLInsertClauseAlter(Connection connection, ConfigurationEx configuration, RelationalPath<?> entity) {
		super(connection, configuration.get(), entity);
		this.configEx=configuration;
	}

	public SQLInsertClauseAlter(Supplier<Connection> connection, ConfigurationEx configuration, RelationalPath<?> entity, SQLQuery<?> subQuery) {
		super(connection, configuration.get(), entity, subQuery);
		this.configEx=configuration;
	}

	public SQLInsertClauseAlter(Supplier<Connection> connection, ConfigurationEx configuration, RelationalPath<?> entity) {
		super(connection, configuration.get(), entity);
		this.configEx=configuration;
	}
	
	/**
	 * 添加自动生成值的字段
	 */
	public SQLInsertClauseAlter populateAutoGeneratedColumns() {
    	RelationalPathEx<?> entity=(RelationalPathEx<?>)this.entity;
    	List<Path<?>> paths = entity.getColumns();
    	for(Path<?> p:paths) {
    		ColumnMapping metadata=entity.getColumnMetadata(p);
    		//用户没有显式设置过值时才会填充字段
    		if(metadata.getGenerated()==null) {
    			continue;
    		}
    		if(columns.indexOf(p)>=0) {
    			continue;
    		}
    		Object value=AdvancedMapper.asAutoValue(metadata.getGenerated(), metadata, AdvancedMapper.SCENARIO_INSERT);
    		if (value instanceof Expression<?>) {
    			columns.add(p);
    			values.add((Expression<?>)value);
    	    }else if(!metadata.isUnsavedValue(value)) {
    	    	columns.add(p);
    	    	values.add(ConstantImpl.create(value));
			}
    	}
    	return this;
    }

	/**
	 * Execute the clause and return the generated keys as a ResultSet
	 *
	 * @return result set with generated keys
	 */
	public ResultSet executeWithKeys() {
		context = startContext(connection(), metadata, entity);
		try {
			PreparedStatement stmt = null;
			if (batches.isEmpty()) {
				stmt = createStatement(true);
				listeners.notifyInsert(entity, metadata, columns, values, subQuery);

				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
			} else if (batchToBulk) {
				stmt = createStatement(true);
				listeners.notifyInserts(entity, metadata, batches);

				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
			} else {
				Collection<PreparedStatement> stmts = createStatements(true);
				if (stmts != null && stmts.size() > 1) {
					throw new IllegalStateException("executeWithKeys called with batch statement and multiple SQL strings");
				}
				stmt = stmts.iterator().next();
				listeners.notifyInserts(entity, metadata, batches);

				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int[] rc = stmt.executeBatch();
				long count = 0;
				for (int r : rc) {
					count = count + r;
				}
				postExecuted(context, System.currentTimeMillis() - start, "BatchInsert", count);
			}

			final Statement stmt2 = stmt;
			ResultSet rs = stmt.getGeneratedKeys();
			return new ResultSetAdapter(rs) {
				@Override
				public void close() throws SQLException {
					try {
						super.close();
					} finally {
						stmt2.close();
						reset();
						endContext(context);
					}
				}
			};
		} catch (SQLException e) {
			onException(context, e);
			reset();
			endContext(context);
			throw configuration.translate(queryString, constants, e);
		}
	}

	@Override
	public long execute() {
		context = startContext(connection(), metadata, entity);
		PreparedStatement stmt = null;
		Collection<PreparedStatement> stmts = null;
		try {
			if (batches.isEmpty()) {
				//没有任何数据需要插入
				if(populatedEmptyBatch && columns.isEmpty()) {
					return 0;
				}
				stmt = createStatement(false);
				listeners.notifyInsert(entity, metadata, columns, values, subQuery);

				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
				return rc;
			} else if (batchToBulk) {
				stmt = createStatement(false);
				listeners.notifyInserts(entity, metadata, batches);

				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				int rc = stmt.executeUpdate();
				postExecuted(context, System.currentTimeMillis() - start, "Insert", rc);
				return rc;
			} else {
				stmts = createStatements(false);
				listeners.notifyInserts(entity, metadata, batches);

				listeners.preExecute(context);
				long start = System.currentTimeMillis();
				long rc = executeBatch(stmts);
				postExecuted(context, System.currentTimeMillis() - start, "BatchInsert", rc);
				return rc;
			}
		} catch (SQLException e) {
			onException(context, e);
			throw configuration.translate(queryString, constants, e);
		} finally {
			if (stmt != null) {
				close(stmt);
			}
			if (stmts != null) {
				close(stmts);
			}
			reset();
			endContext(context);
		}
	}

	/**
	 * 使用带NULLBinding的方式设置变量，批量装配时，无论是否为null值，都会在SQL中显示声明，因此数据库的默认值将无效
	 * @param beans
	 * @return this
	 */
	public SQLInsertClauseAlter populateBatch(Collection<?> beans) {
		populateBatch0(beans, FOR_BATCHINSERT);
		return this;
	}
	
	public <T> SQLInsertClauseAlter populateBatch(Collection<T> beans, Mapper<T> mapper) {
		populateBatch0(beans, mapper);
		return this;		
	}
	
	/**
	 * 批量写入动态数据（用Tuple类型表示）
	 * @param beans 数据
	 * @param mapper Tuple
	 * @return this
	 */
	public <T> SQLInsertClauseAlter populateTuples(Collection<Tuple> beans) {
		populateBatch0(beans, FOR_TUPLE_BATCHINSERT);
		return this;		
	}
	
	@SuppressWarnings({ "rawtypes", "unchecked" })
	private void populateBatch0(Collection beans, Mapper mapper) {
		if(beans==null || beans.isEmpty()) {
			populatedEmptyBatch = true;
			return;
		}
		for (Object obj : beans) {
			Map<Path<?>, Object> values = mapper.createMap(entity, obj);
			for (Map.Entry<Path<?>, Object> entry : values.entrySet()) {
				set((Path) entry.getKey(), entry.getValue());
			}
			addBatch();
		}
	}
	
	private transient boolean populatedEmptyBatch; 
	
	/**
	 * 覆盖父类实现，使用默认的AdvancedMapper，支持primtive类型字段，并可支持注解@UnsavedValue
	 */
	public SQLInsertClauseAlter populate(Object bean) {
		return populate(bean, FOR_INSERT);
	}
	
	public SQLInsertClauseAlter populate(Tuple bean) {
		return populate(bean, FOR_TUPLE_INSERT);
	}

//	@SuppressWarnings({ "unchecked", "rawtypes" })
//	public SQLInsertClauseAlter populate(Object bean, Mapper<?> mapper) {
//		Map<Path<?>, Object> values = mapper.createMap(entity, bean);
//		for (Map.Entry<Path<?>, Object> entry : values.entrySet()) {
//			set((Path) entry.getKey(), entry.getValue());
//		}
//		return this;
//	}
	
    protected Collection<PreparedStatement> createStatements(boolean withKeys) throws SQLException {
        boolean addBatches = !configuration.getUseLiterals();
        listeners.preRender(context);

        if (subQueryBuilder != null) {
            subQuery = subQueryBuilder.select(values.toArray(new Expression[0])).clone();
            values.clear();
        }

        Map<String, PreparedStatement> stmts = new HashMap<>();

        // add first batch
        {
        	SQLSerializerAlter serializer = new SQLSerializerAlter(configEx, true);
        	serializer.setUseLiterals(useLiterals);
        	serializer.setRouting(routing);
			SQLInsertBatch batch = batches.get(0);
            serializer.serializeInsert(metadata, entity, batch.getColumns(), batch.getValues(), batch.getSubQuery());
            String sql=serializer.toString();
            
            PreparedStatement stmt = prepareStatementAndSetParameters(new SQLBindingsAlter(sql,serializer.getConstants(),serializer.getConstantPaths()), withKeys);
            if (addBatches) {
                stmt.addBatch();
            }
            stmts.put(sql, stmt);
            context.addSQL(createBindings(metadata, serializer));
            listeners.rendered(context);	
        }
        // add other batches
		int maxLoginBatch = configEx.getMaxRecordsLogInBatch();
        for (int i = 1; i < batches.size(); i++) {
            SQLInsertBatch batch = batches.get(i);

            listeners.preRender(context);
        	SQLSerializerAlter serializer = new SQLSerializerAlter(configEx, true);
        	serializer.setUseLiterals(useLiterals);
        	serializer.setRouting(routing);
            serializer.serializeInsert(metadata, entity, batch.getColumns(),batch.getValues(), batch.getSubQuery());
            String sql=serializer.toString();
            
			if (i <= maxLoginBatch) {
            	context.addSQL(createBindings(metadata, serializer));
                listeners.rendered(context);	
            }
            PreparedStatement stmt = stmts.get(serializer.toString());
            if (stmt == null) {
                stmt = prepareStatementAndSetParameters(new SQLBindingsAlter(sql,serializer.getConstants(),serializer.getConstantPaths()), withKeys);
                stmts.put(serializer.toString(), stmt);
            } else {
                setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(),
                        metadata.getParams());
            }
            if (addBatches) {
                stmt.addBatch();
            }
        }
        if(stmts.size()>1) {
        	log.warn("There are multi sqls in this batch.{}",stmts.keySet());
        }
        return stmts.values();
    }

	
	protected PreparedStatement createStatement(boolean withKeys) throws SQLException {
		listeners.preRender(context);
		SQLSerializerAlter serializer = new SQLSerializerAlter(configEx, true);
        serializer.setUseLiterals(useLiterals);
        serializer.setRouting(routing);
		if (subQueryBuilder != null) {
			subQuery = subQueryBuilder.select(values.toArray(new Expression[values.size()])).clone();
			values.clear();
		}

		if (!batches.isEmpty() && batchToBulk) {
			serializer.serializeInsert(metadata, entity, batches);
		} else {
			serializer.serializeInsert(metadata, entity, columns, values, subQuery);
		}
		SQLBindingsAlter bindings = createBindings(metadata, serializer);
		context.addSQL(bindings);
		listeners.rendered(context);
		return prepareStatementAndSetParameters(serializer, withKeys);
	}

	protected PreparedStatement prepareStatementAndSetParameters(SQLBindingsAlter bindings, boolean withKeys) throws SQLException {
		listeners.prePrepare(context);

		this.queryString = bindings.getSQL();
		this.constants = bindings.getNullFriendlyBindings();
//        logQuery(logger, queryString, constants);
		PreparedStatement stmt;
		if (withKeys) {
			if (entity.getPrimaryKey() != null) {
				String[] target = new String[entity.getPrimaryKey().getLocalColumns().size()];
				for (int i = 0; i < target.length; i++) {
					Path<?> path = entity.getPrimaryKey().getLocalColumns().get(i);
					String column = ColumnMetadata.getName(path);
					target[i] = column;
				}
				stmt = connection().prepareStatement(queryString, target);
			} else {
				stmt = connection().prepareStatement(queryString, Statement.RETURN_GENERATED_KEYS);
			}
		} else {
			stmt = connection().prepareStatement(queryString);
		}
		setParameters(stmt, constants, bindings.getPaths(), metadata.getParams());

		context.addPreparedStatement(stmt);
		listeners.prepared(context);
		return stmt;
	}
	
	  protected void setParameters(PreparedStatement stmt, List<?> objects,
	            List<Path<?>> constantPaths, Map<ParamExpression<?>, ?> params) {
	        if (objects.size() != constantPaths.size()) {
	            throw new IllegalArgumentException("Expected " + objects.size() + " paths, " +
	                    "but got " + constantPaths.size());
	        }
	        for (int i = 0; i < objects.size(); i++) {
	            Object o = objects.get(i);
	            try {
	                if (o instanceof ParamExpression) {
	                    if (!params.containsKey(o)) {
	                        throw new ParamNotSetException((ParamExpression<?>) o);
	                    }
	                    o = params.get(o);
	                }
	                configuration.set(stmt, constantPaths.get(i), i + 1, o);
	            } catch (SQLException e) {
					Path<?> p = constantPaths == null ? null : constantPaths.get(i);
					log.error(queryString+ "\nField " + i + " path=" + p + " set error. " + e.getMessage());
	                throw configuration.translate(e);
	            }
	        }
	    }

	@Override
	protected SQLBindingsAlter createBindings(QueryMetadata metadata, SQLSerializer serializer) {
		String queryString = serializer.toString();
		List<Object> args = new ArrayList<>();
		Map<ParamExpression<?>, Object> params = metadata.getParams();
		for (Object o : serializer.getConstants()) {
			if (o instanceof ParamExpression) {
				if (!params.containsKey(o)) {
					throw new ParamNotSetException((ParamExpression<?>) o);
				}
				o = metadata.getParams().get(o);
			}
			args.add(o);
		}
		return new SQLBindingsAlter(queryString, args, serializer.getConstantPaths());
	}

	private void postExecuted(SQLListenerContextImpl context, long cost, String action, long count) {
		context.setData(ContextKeyConstants.ELAPSED_TIME, cost);
		context.setData(ContextKeyConstants.COUNT, count);
		context.setData(ContextKeyConstants.ACTION, action);
		if(this.configEx.getSlowSqlWarnMillis()<=cost) {
			context.setData(ContextKeyConstants.SLOW_SQL, Boolean.TRUE);
		}
		listeners.executed(context);
	}
	
	public SQLInsertClauseAlter withRouting(RoutingStrategy routing){
		this.routing = routing;
		return this;
	}
}
