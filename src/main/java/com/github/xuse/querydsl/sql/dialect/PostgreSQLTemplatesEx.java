package com.github.xuse.querydsl.sql.dialect;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.Arrays;
import java.util.List;

import com.github.xuse.querydsl.sql.dbmeta.InfomationSchemaReader;
import com.github.xuse.querydsl.sql.dbmeta.PartitionInfo;
import com.github.xuse.querydsl.sql.dbmeta.SchemaReader;
import com.github.xuse.querydsl.sql.ddl.ConnectionWrapper;
import com.github.xuse.querydsl.sql.ddl.ConstraintType;
import com.github.xuse.querydsl.sql.ddl.DDLOps;
import com.github.xuse.querydsl.sql.ddl.DDLOps.AlterColumnOps;
import com.github.xuse.querydsl.sql.ddl.DDLOps.AlterTableConstraintOps;
import com.github.xuse.querydsl.sql.ddl.DDLOps.AlterTablePartitionOps;
import com.github.xuse.querydsl.sql.ddl.DDLOps.PartitionDefineOps;
import com.github.xuse.querydsl.sql.ddl.DDLOps.PartitionMethod;
import com.github.xuse.querydsl.util.StringUtils;
import com.querydsl.core.types.SQLTemplatesEx;
import com.querydsl.sql.SQLBindings;
import com.querydsl.sql.SQLTemplates;
import com.querydsl.sql.TemplatesAccessor;
import com.querydsl.sql.namemapping.ChangeLetterCaseNameMapping.LetterCase;

public class PostgreSQLTemplatesEx extends DefaultSQLTemplatesEx {
	public final int jdbcTypeOfBytea;

	private SchemaReader schemaReader = new PgSchemaReader();

	public PostgreSQLTemplatesEx(SQLTemplates template) {
		// PG驱动认为bytea的jdbc类型是BINARY，今后如果修改可以调用另外一个构造。
		this(template, Types.BINARY);
	}

	public PostgreSQLTemplatesEx(SQLTemplates template, int jdbcTypeOfBytea) {
		super(template);
		this.jdbcTypeOfBytea = jdbcTypeOfBytea;

		// bool/boolean 占1字节，PG仅有 bit string类型不等于bit。PG驱动将boolean类型视为bit.
		typeNames.put(Types.BIT, "boolean").type(Types.BIT).noSize();
		typeNames.put(Types.BOOLEAN, "boolean").type(Types.BIT).noSize();

		// 没有tinyint类型
		typeNames.put(Types.TINYINT, "smallint").type(Types.SMALLINT).noSize();
		typeNames.put(Types.DOUBLE, "double precision").noSize();
		// float视为double类型
		typeNames.put(Types.FLOAT, "float").type(Types.DOUBLE).noSize();

		typeNames.put(Types.CLOB, "text").noSize();

		// PG仅有二进制类型bytea，(0, 2147483647)，但JDBC驱动认为是BINARY类型，但有点不合理，考虑以后变化的可能。
		typeNames.put(Types.BLOB, "bytea").type(jdbcTypeOfBytea).noSize();
		typeNames.put(Types.BINARY, "bytea").type(jdbcTypeOfBytea).noSize();
		typeNames.put(Types.VARBINARY, "bytea").type(jdbcTypeOfBytea).noSize();
		typeNames.put(Types.LONGVARBINARY, "bytea").type(jdbcTypeOfBytea).noSize();

		typeNames.put(Types.NUMERIC, "numeric($p, $s)");
		typeNames.put(Types.DECIMAL, "decimal($p, $s)").type(Types.NUMERIC);// 驱动内部认为都是Numeric类型

		// pg 默认的时间精度是毫秒，即6。故要生成秒级时间戳需要显式指定0
		typeNames.put(Types.TIME, "time(0)").size(0);
		typeNames.put(Types.TIMESTAMP, "timestamp(0)").size(0);

		typeNames.put(Types.TIMESTAMP, 6, "timestamp($l)");
		typeNames.put(Types.TIMESTAMP, 1024, "timestamp($l)").size(6);

		typeNames.put(Types.TIME, 6, "time($l)");
		typeNames.put(Types.TIME, 1024, "time($l)").size(6);
	}

	@Override
	public String translateDefault(String columnDef, int type, int size, int digits) {
		// 已经是表达式了
		return columnDef;
	}

	@Override
	public SizeParser getColumnSizeParser(int jdbcType) {
		switch (jdbcType) {
		case Types.TIMESTAMP:
		case Types.TIME:
			return SizeParser.TIME_DIGIT_AS_SIZE;
		default:
			return SizeParser.DEFAULT;
		}
	}

	@Override
	public void init(SQLTemplates templates) {
		SQLTemplatesEx.initDefaultDDLTemplate(templates);

		TemplatesAccessor.setAutoIncrement(templates, " generated by default as identity");

		add(templates, DDLOps.COLUMN_ALLOW_NULL, "");
		add(templates, DDLOps.CHARSET, "{0}");
		add(templates, DDLOps.COLLATE, "{0}");
		add(templates, DDLOps.UNSIGNED, "{0}");
		add(templates, DDLOps.COMMENT_ON_COLUMN, "COMMENT ON COLUMN {0} IS {1}");
		add(templates, DDLOps.COMMENT_ON_TABLE, "COMMENT ON TABLE {0} IS {1}");
		add(templates, AlterColumnOps.SET_DATATYPE, "SET DATA TYPE {0}");
		// add(templates, AlterColumnOps.SET_DATATYPE, "{0}");

		add(templates, ConstraintType.UNIQUE, "CONSTRAINT {1} UNIQUE{2}");
		// add(templates, Basic.SELECT_VALUES, "values {0}");
		// add(templates, ConstraintType.UNIQUE, "CONSTRAINT {1} UNIQUE {2}");
//		add(templates, SpecialFeature.ONE_COLUMN_IN_SINGLE_DDL, "");
//				AlterTableOps.CHANGE_COLUMN,DDLOps.COLLATE, AlterTableConstraintOps.ALTER_TABLE_DROP_BITMAP,
//				AlterTableConstraintOps.ALTER_TABLE_DROP_KEY

		add(templates, SpecialFeature.INDEPENDENT_COMMENT_STATEMENT, "");
		//add(templates, SpecialFeature.PARTITION_SUPPORT, "");
		add(templates, SpecialFeature.INDEPENDENT_PARTITION_CREATION, "");
		add(templates, SpecialFeature.NO_PRIMARY_KEY_ON_PARTITION_TABLE, "");
		
		initPartitionOps(templates);
		
		addUnsupports(DDLOps.UNSIGNED);
		addUnsupports(DDLOps.COLLATE, AlterTableConstraintOps.ALTER_TABLE_DROP_BITMAP,
				AlterTableConstraintOps.ALTER_TABLE_DROP_KEY);
	}
	
	private void initPartitionOps(SQLTemplates templates) {
		add(templates,PartitionDefineOps.PARTITION_BY,"PARTITION BY {0}");
		//官方文档上说有Hash Partition但没有示例，在PG14上测试不通过，视为不支持
//		add(templates,PartitionMethod.KEY,"HASH({0}) PARTITIONS {1}");
//		add(templates,PartitionMethod.HASH,"HASH({0}) PARTITIONS {1}");
		
		//不支持
		//add(templates,PartitionMethod.LINEAR_HASH," LINEAR HASH({0}) PARTITIONS {1}");
		//不支持
//		add(templates,AlterTablePartitionOps.REORGANIZE_PARTITION," REORGANIZE PARTITION {0} INTO {1}");
		
		add(templates,PartitionMethod.RANGE,"RANGE ({0})");
		add(templates,PartitionMethod.RANGE_COLUMNS,"RANGE ({0})");
		add(templates,PartitionMethod.LIST,"LIST ({0})");
		add(templates,PartitionMethod.LIST_COLUMNS,"LIST ({0})");
		
		//创建语句不是通过修改表实现的
		add(templates,AlterTablePartitionOps.ADD_PARTITION,"{0}");
		add(templates,PartitionDefineOps.PARTITION_IN_LIST,"CREATE TABLE {1}_{0} PARTITION OF {1} FOR VALUES IN ({2})");
		add(templates,PartitionDefineOps.PARTITION_FROM_TO,"CREATE TABLE {1}_{0} PARTITION OF {1} FOR VALUES FROM {2} TO {3}");
		
	}

	@Override
	public boolean supportCreateInTableDefinition(ConstraintType type) {
		return !type.isIndex();
	}

	@Override
	public LetterCase getDefaultLetterCase() {
		return LetterCase.LOWER;
	}

	@Override
	public SchemaReader getSchemaAccessor() {
		return schemaReader;
	}
	

	static class PgSchemaReader extends InfomationSchemaReader {
		public PgSchemaReader() {
			super(InfomationSchemaReader.FILTER_NOT_NULL_CHECK | InfomationSchemaReader.HAS_CHECK_CONSTRAINTS
					| InfomationSchemaReader.REMOVE_BUCKET_FOR_CHECK);
		}

		@Override
		public List<PartitionInfo> getPartitions(String catalog, String schema, String tableName,
				ConnectionWrapper conn) {
			String sql = "select current_database()  as table_cat,\r\n"
					+ "    pns.nspname as table_schema, parent.relname as table_name, \r\n"
					+ "    mns.nspname as partition_schema,my.relname as partition_name,\r\n"
					+ "    pg_get_expr(my.relpartbound, parent.oid) as bound,\r\n"
					+ "    case pdef.partstrat when 'h' then 'HASH' when 'l' then 'LIST' when 'r' then 'RANGE' else null end as partition_method,\r\n"
					+ "    pdef.partnatts as column_count,\r\n"
					+ "    pdef.partexprs\r\n"
					+ "    from pg_catalog.pg_inherits ih\r\n"
					+ "    left join pg_class as parent on parent.oid=ih.inhparent \r\n"
					+ "    left join pg_class as my on my.oid=ih.inhrelid \r\n"
					+ "    left join pg_namespace as pns on pns.oid=parent.relnamespace \r\n"
					+ "    left join pg_namespace as mns on mns.oid=my.relnamespace \r\n"
					+ "    left join pg_partitioned_table pdef on pdef.partrelid=parent.oid\r\n"
					+ "    where pns.nspname=? and parent.relname=?";
			
			SQLBindings bind = new SQLBindings(sql, Arrays.asList(mergeSchema(catalog, schema), tableName));
			List<PartitionInfo> partitions = conn.query(bind, this::convert);
			return partitions;
		}

		private PartitionInfo convert(ResultSet rs) throws SQLException {
			PartitionInfo info = new PartitionInfo(true);
			info.setTableCat(rs.getString(1));//
			info.setTableSchema(rs.getString(2));
			info.setTableName(rs.getString(3));
			
			info.setName(rs.getString(5));
			info.setPartitionDescription(rs.getString(6));
			String method=rs.getString(7);
			if (StringUtils.isNotEmpty(method)) {
				info.setMethod(PartitionMethod.valueOf(method));
			}
			//分区字段拿不到
//			info.setPartitionExpression(rs.getString(6));
//			info.setCreateTime(null);
//			info.setPartitionOrdinal();
			return info;
		}
	}

}
