# Why Query-dsl?

**Contents**
- [Why Query-dsl?](#why-query-dsl)
  - [什么是QueryDSL](#什么是querydsl)
  - [推荐使用本框架的理由](#推荐使用本框架的理由)
  - [为什么可以用Querydsl代替JPA](#为什么可以用querydsl代替jpa)
  - [一点感想](#一点感想)
  - [附：Java常见数据库访问的技术路线对比](#附java常见数据库访问的技术路线对比)
    - [JPA路线](#jpa路线)
    - [数据访问层常用路线——JDBC路线](#数据访问层常用路线jdbc路线)
    - [MB路线](#mb路线)
    - [理想的SQL持久层框架](#理想的sql持久层框架)


这里解释一下为什么我从其他数据库框架最终切换到现在的技术路线上，并且这个框架是为什么而诞生的。

## 什么是QueryDSL

[QueryDSL](https://github.com/querydsl/querydsl) 是一个历史悠久的SQL查询构建器。

在Hibernate和JPA大行其道的年代里，开发者很快发现ORM无法表达一些稍微复杂的查询，更不要说带有多个组合查询了。Hibernate的方案是引入HQL，JPA的方案是引入QueryBuilder和NativeQuery，然而这些方案都不完美，逐渐被淘汰。大约在2015左右，我在编写GeeQuery以支持Spring-data的时候，发现Spring-Data引入了一套的新的QueryBuilder，即是QueryDSL。

QueryDSL是针对SQL的词法树抽象进行建模的，这就使得它的查询模型非常丰富，几乎能涵盖查询语言（如SQL）的所有功能。QueryDSL用相同的方法为Lucene、JPA、ES、JDO、Mongo等都进行了查询模型的建模，使得开发者可以在强语法和类型检查的情况下访问持久层。

如果开发者直接使用JSON、SQL、HQL、JPQL等查询语言，只能基于字符串拼接完成。而字符串拼接对于一个长期维护的业务项目是非常危险且繁琐的。开发者无法知道改对了没有，也无法确认要修改的代码位置是否都得到了修改。

QueryDSL提供了友好的查询构建API，接近SQL且符合自然语言习惯。我在试用后就发现使用它编写的业务代码可读性很强且没有冗余代码，它的潜力巨大，可以说是一个理想的数据库Facade。 (这种风格大概在十多年前就有了，近几年很多新框架参照了类似的用法。)

在这个基础上，我将自己使用querydsl中用到的一些功能包装了一下，就有个这个框架。前面已经说过querydsl的查询构建界面(Facade)非常好，所以我针对对象构造与反射等场合作了重写，以期将性能推到极致，就此使用了好多年，功能上逐步接近我对数据库访问工具的理想期望。

## 推荐使用本框架的理由

**来自Querydsl的特性**

* 在各种各样针对数据库访问的Query API中，在QueryDSL是最友好的QueryBuilder之一。很多JPA使用者已经熟悉了QueryDSL的用法。
* 能提供的SQL特性极为全面。是除了直接操作SQL语句之外，数据库访问灵活性最强的框架（没有之一）。
* 与xxQL不同，Query API的技术路线可以带来类型安全的编译期语法检查，使得项目的维护成本不会失控。
* 对于跨数据库移植性有较好的支持。

**来自本框架扩展(querydsl-sql-extension)的特性**

* 有着在JDBC之上数据库框架中最佳的性能。
* 补充了单表增删改查等JPA的基本特性，在简单查询开发效率上不输于JPA。
* 是功能最全面最完整的数据库访问框架之一
  - 支持数据库表结构的分析、对比，数据库表结构更新等API，通过包扫描等操作，具备了Hibernate的启动自动维护数据库表的能力。
    同时DDL能力也作为API开放给开发者使用。
  - 其他一些实用功能，比如业务层分表兼容、数据表初始化数据导入等，将开发者与SQL语句做出彻底切割。

**其他**

* 提供Connection对象，对不得不使用JDBC或SQL的场合也能支持。
* Java开发生态中，互联网行业几乎都放弃了JPA路线，转入了JDBC和MB路线（参见本文附录：数据库层常用技术路线介绍）。这让他们的业务几乎失去类型安全和语法检查等维护特性。这是十分可惜的。本框架的一个重要意义是——能够让互联网行业的java开发重新获得类似JPA的开发效率和编译期检查能力。
  本框架甚至还提供了一定的跨数据库移植特性，虽然互联网行业普遍不看重这个特性，然而谁能保证自己未来不做私有化的ToB业务呢？
* 如果是QueryAPI路线，本框架可能是最佳的选择。
  

## 为什么可以用Querydsl代替JPA

大部分了解QueryDSL的开发人员，基本都是通过JPA学习QueryDSL的，他们眼中QueryDSL是JPA查询构建的一个补充机制。

所以有必要介绍一下我为什么推荐用QueryDSL代替JPA。

实际上我本人也是从JPA路线转换过来，过程大概经历了这样几步：

- 使用MyBatis，在一个8人团队并且配备了开发DBA的长达两年的维护项目中，在DBA指导下需要频繁优化数据库结构和查询语句，多人修改的、分散的、大量多表关联的SQL语句和片段维护，由于没有编译器和类型安全的检查，耗费了团队极大的精力。
- 使用JPA和JPQL、QueryBuilder（从流行实现逐步更换为自有JPA实现，参见拙作GeeQuery）
- 使用Spring-data，发现并使用Spring-Data引入的queryDSL作为查询构建器。我在使用querydsl后就发现使用它编写的业务代码可读性很强且没有冗余代码，尤其是很好地解决了数据库访问的编译期检查问题。
- 某一天，我这样想到：querydsl-jpa作为查询构建器可以处理复杂的数据库访问，而JPA能提供的无非就是单表增删改查、级联和延迟加载功能。
  用querydsl把单表增删改封装成常用的JPA增删改查几乎没有难度。对于级联和延迟加载功能似乎也不是非要不可，那我还留着JPA干啥？

我们来看看有什么JPA支持，但是queryDSL + 本框架无法完成的事情吧。

* 简单的单表操作：使用save / merge /load / update等方法，直接传入一个对象即完成常用的增删该查操作。
  答：在封装后的GenericRepository中提供了类似的特性。无需自行拼装query对象。【可代替】

* 复杂的多表操作：在JPA中也使用querydsl语法构造查询，切换后没有任何变化。【可代替】

* 特别复杂的统计类SQL语句，无法通过API构建查询：在JPA中是NativeQuery。本框架目前未提供NativeQuery特性，建议使用Spring-jdbc 代替。因为Spring-JDBC用法更为广泛和流行，也能完成对象字段映射等ORM基本功能，有必要再封装。本框架能与Spring-JDBC协同共享同一个事务。【可通过补充方案解决】

* LOB延迟加载。

  答：从实际用法看：绝大多数情况下，在执行对象首次查询之前，业务需不需要使用LOB字段是已经明确的事情。因此延迟加载LOB字段将原本一次数据库交互变成了两次，并不是什么好做法。JPA需要这个特性的原因是JPA中无法精确指定SELECT语句中需要的列，而QueryDSL在执行查询前就可以灵活指定需要的列——需要就查询，不需要就是不查。这个功能与其说是一种特性，不如说是对JPA自身缺陷的一种补偿方法。
  【用一次查询指定字段的方式替代】

* 级联（Cascade）, @OneToOne @OneToMany @ManyToOne @ManyToMany。可以直接从一个对象使用get方法获得级联关系数据。
  答：这是一个提升开发效率的好功能，但是支持级联后，性能问题风险大幅增加。企业和小型项目这样用的也不少，互联网行业应该没有这样用的。
  对于以性能作为优点的本框架来说，本框架更多推荐给性能敏感的大型企业项目或互联网行业。本框架目前还没有支持，今后可能以SPI的方式扩展这个特性。如果您很看重这个特性，也可以提Issue给我。
【今后考虑扩展支持】
  
* L1/L2 Cache

  答：本框架没有实现任何一个对象缓存功能。主要原因如下——

  * 设计理念中是提供一个轻量、容易掌握、可观测性强的框架。本框架是数据库的封装，会尽可能把数据库的能力暴露给开发者，而不是在中间做很多其他事情。本框架几乎提供了无缓情况下数据库访问的最好性能，灵活地把数据库用好，而不是用缓存去制造新的问题。
  * 对于分布式应用来说，多实例并发访问是很常见的事情，缓存会把问题搞复杂。
  * 数据库不提供可重复读的场景下，框架也不应去做可重复读之类改变数据库行为的事情。
  * 现代缓存框架很多，Spring也作了很方便的封装；对于加速业务来说，贴近业务的粗粒度缓存要比数据库层面缓存有效得多。本框架没有必要去干预架构师的缓存决策。
  
  【不是刚需，用业务级缓存代替（如Spring Cache配合Caffine 或 Redis等）

## 一点感想

这个框架可以说是无心偶得，今后也会佛系维护。

2017：有了替换JPA的想法后，说干就干，去除了JPA，仅留下querydsl-sql模块。本着最小修改的原则，对QueryDSL的监听行为进行扩展，从而可以得到更详细的日志信息。

2018：性能演进
既然打算今后长期使用了，对性能吹毛求疵的我自然不能接受原生的反射操作，于是进行了优化。这个框架就此诞生。增加了基于ASM自动生成动态类来完成字段拼装对象，无反射调用，还有一些代码BUG的修改。

2019~2023：自用阶段
之后就是自己用得非常爽快，期间仅对一些常用的功能进行了小改，使得代码更简洁。如自动时间戳、自动生成GUID等。

2024：扩展改造
在使用过程中，阅读源码中发现原作者一开始是想要支持DDL语法的，后来不知道为什么没有再支持了。可能确实使用场景不太多，总归有点小缺憾，由于我早年在GQ上写过相关的功能，于是花了不少时间在目前的框架上支持了DDL语法。
另外还有些朋友喜欢无代码自动生成，无Query class的纯POJO用法，为此也作了一些适配来降低使用门槛。

今后：保持轻量是维护的宗旨，不会再考虑加入什么乐观锁、词法分析器、分库分表、内置连接池之类的东西，虽然都写过，但是将它们糅合在一起没有必要。



最后：如果有使用下来觉得不错的朋友，无需给这个项目Star，请 Star [QueryDSL](https://github.com/querydsl/querydsl) 项目，各位觉得好的设计都来自QueryDSL，我只是为自利做了一些微不足道的增强而已。



## 附：Java常见数据库访问的技术路线对比

### JPA路线

对比下表可发现，该路线对于 单表应用/ 小规模企业应用 的开发者是较为适合的。但是要想精通，需要专门学习框架自身知识体系——HQL / JPQL / QueryBuilder/ QueryDSL-JPA /SpringData-JPA /Hiberbate自身的对象管理和缓存机制 等等。

* 这也是整个JPA路线的问题——技术栈很深，但和数据库设计 / SQL优化等不在一个方向上。
* 抽象的JPQL为了解决兼容所有RDBMS的目的，有很多限制，无法最大化利用数据库的特性（比如 RowId, 窗口分析函数等）。

|      | JPA / Hibernate                                              | Spring Data -JPA                                             | QueryDSL-JPA                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 介绍 | 纯面向对象的数据访问，但实际<br />关系数据库的能力很难用一个虚拟的“对象库”代替。<br />因此需要使用HQL语言完成复杂查询。<br />JPA为了替代HQL，设计了QueryBuilder，但是API也比较复杂，并且JPA还设计了JPQL查询语言。<br />加上各种缓存、投影等复杂操作，入门易精通难 | Srpingframework针对JPA进行的封装（也封装了其他很多持久层框架），保留了JPA的所有功能 | 思路与Spring-Data如出一辙，API更易用。一般搭配搭配Spring Data-JPA使用，该路线的终极解决方案。 |
| 优点 | * 单表操作极其简便  <br />* @OneToOne @OneToMany @ManyToOne等注解，多表关联和延迟加载无需编码<br />* LOB字段延迟加载 | * JPA的所有优点<br />* 基于接口定义的方法名自动生成实现代理<br />* 引入querydsl-jpa作为替代的查询构建器。比JPA规范更符合开发者直觉。 | * 搭配Spring data-JPA使用，具有前者的全部优点<br />* 复杂查询构建方便 |
| 缺点 | 自由度较低<br />性能难控制<br />性能依赖缓存，而在多实例应用中，数据库层级的缓存存在无法刷新问题<br />低层级的缓存在复杂业务中不能代替粗粒度的业务数据缓存，整个缓存架构变得更复杂 | * JPA的所有缺点<br />* 本质上还是基于JPA的，要精通还是要深入学习JPA的所有知识<br /> | * JPA的所有缺点<br />* 三套框架的学习成本，                  |

### 数据访问层常用路线——JDBC路线

对比下表可以发现，虽然是JDBC路线，但querydsl-sql是所有框架中唯一做到以下两点的框架：

* 开发者无需编写 xxQL （HQL / JPQL /SQL），仅需掌握**一套API**即可完成（在不同RDBMS上的）几乎所有数据库操作。
* 开发者无需接触JDBC API，无需自行处理结果映射。

|      | SpringData -JDBC /JDBCTemplate                               | querydsl-sql                                                 | querydsl-sql-extension<br />(本框架)                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 介绍 | Srpingframework针对JDBC的封装，帮助开发者完成从JDBC到Java字段的简单映射，提升效率。 | 对数据库和SQL特性进行建模，提供了直观、简便的API。<br />内部使用了AST（抽象词法树）来描述针对数据库访问请求建模、 | 在querydsl-sql基础上封装。保留了querydsl-sql的特点。         |
| 优点 | * 基于接口定义的方法名自动生成实现代理                       | * 虽然是JDBC路线，但AST的模型包装了几乎所有SQL操作，开发者无需编写SQL，无需字符串拼接。<br />* 提供了各种数据库到java对象返回结果的映射（单列数据/多表任意列返回/指定列数据等）<br />* 数据库可移植性： 通过SQL AST + SQL方言模版，能做到一套数据库访问模型通吃所有数据库类型。一次编写，所有数据库上可运行。 | * querydsl-sql的所有优点<br />* 性能极致（参见后文）<br />* 单表等简单场合的API操作无需编码实现，解决开发效率问题。<br />* 支持近年来流行的Lambda代替数据表模型，无需生成Quey class. |
| 缺点 | * 封装程度不高，开发者需要熟练掌握SQL和JDBC规范，<br />* 复杂映射需要自行处理JDBC ResultSet对象。<br />* 不提供任何辅助数据库可移植性的特性。 | * 提供的API基于SQL AST模型，有种用java语言编写SQL的感觉，单表等简单操作也要编码实现，效率不够高 | *在本路线框架中没发现缺点。对比JPA类框架，没支持自动级联（@OneToOne @OneToMany等）和延迟加载，但提供了便捷的多表Join query和数据返回映射。 |

> 其实所有框架都是在JDBC上的封装，级联和延迟功能要支持一下也不麻烦，未来可能通过SPI扩展方式提供。

### MB路线

这条路线也是基于JDBC封装的，但都基于MyBatis框架。而不直接使用 JDBC。
进入这条路线基本可以放弃数据库可移植性了。因为MyBatis核心是SQL语句拼接而不是AST，因此最终数据库访问模型是用SQL字符串表达的。不过MB的支持者用了SQLParser之类的词法分析器来试图帮助这类框架提升数据库可移植性，以及一些基于MyBatis上层框架也采用了类似AST的模型来表达复杂查询，尤其是国内朋友各种对MyBatis进行“大修大补”的框架，使得这条路线在今天依然是最为流行的路线。但底层的架构决定了这条路线的上限。要解决数据库移植性问题，和重写一套基本没有区别。

>  当然数据库可移植性不一定要在访问框架层解决，还可以通过JDBC驱动（在驱动中通过词法分析修改SQL的行为）、中间件（直接解析数据库网络通信协议）、多语言数据库（现在大多数云数据库和国产数据库支持语法兼容模式）来解决。所以这可能不是什么大问题。

|      | MyBatis                                                      | MyBatis Flex/Plus等                                          |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 介绍 | 很老的框架，基本不更新了。基于JDBC封装，<br />提供了良好的SQL生成引擎和对象映射机制。 | 基于MyBatis的封装。                                          |
| 优点 | * 简便、流行、易学、轻量<br />* 不错的性能                   | * 简便、流行、易学、轻量<br />* Flex提供了自动生成数据表模型的机制（类似querydsl的Query class，或JPA的元模型）<br />* Plus提供了Lambda代替数据表模型的机制 |
| 缺点 | * 几乎没有对数据库可移植性帮助的特性<br />* 手工编写SQL开发效率不高。<br />* 无法使用静态工具（如编译器）对SQL<br />进行编译检查<br /> | * 在SQL基础上增加了Query API，能满足部分甚至大部分操作请求需要，但仍需要开发者编写部分SQL片段<br />* 解决了MyBatis开发效率的问题<br />* 其他MyBatis的缺点 |

### 理想的SQL持久层框架

什么是理想的SQL持久层框架？JPA是非常值得探讨的，JPA是优点和缺点都非常巨大。

* 优点：开发效率高、类型安全并支持语法检查的QueyAPI
* 缺点：性能差、学习成本高、过于重量、结构复杂带来优化与排障难度。

那么如果一个框架咋使用方法上基本对齐JPA，在实现机制上又保持轻量，贴近原生的数据库（SQL和JDBC），这就非常接近理想的形态了。
MyBatis-Plus  / MyBatis-Flex / MyBatis-MB等框架，正是因为在API方面的改进，而集中了上述两条路线的优点，这是新一代框架受欢迎的根本原因。

本框架的目的与上述一致。由于引入了QueryDSL，其API与JPA开发者使用的基本完全一致。正因为此，笔者将其称为“理想的SQL持久层框架”。



