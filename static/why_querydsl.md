# Why query-dsl?

这里解释一下为什么我从其他数据库框架最终切换到现在的技术路线上，并且这个框架是为什么而诞生的。

## 什么是QueryDSL

[QueryDSL](https://github.com/querydsl/querydsl) 是一个历史悠久的SQL查询构建器。

在Hibernate和JPA大行其道的年代里，开发者很快发现ORM无法表达一些稍微复杂的查询，更不要说带有多个组合查询了。Hibernate的方案是引入HQL，JPA的方案是引入QueryBuilder和NativeQuery，然而这些方案都不完美，逐渐被淘汰。大约在2015左右，我在编写GeeQuery以支持Spring-data的时候，发现Spring-Data引入了一套的新的QueryBuilder，即是QueryDSL。

QueryDSL是针对SQL的词法树抽象进行建模的，这就使得它的查询模型非常丰富，几乎能涵盖查询语言（如SQL）的所有功能。QueryDSL用相同的方法为Lucene、JPA、ES、JDO、Mongo等都进行了查询模型的建模，使得开发者可以在强语法和类型检查的情况下访问持久层。

如果开发者直接使用JSON、SQL、HQL、JPQL等查询语言，只能基于字符串拼接完成。而字符串拼接对于一个长期维护的业务项目是非常危险且繁琐的。开发者无法知道改对了没有，也无法确认要修改的代码位置是否都得到了修改。

QueryDSL提供了友好的查询构建API，接近SQL且符合自然语言习惯。我在试用后就发现使用它编写的业务代码可读性很强且没有冗余代码，它的潜力巨大，可以说是一个理想的数据库Facade。 (这种风格大概在十多年前就有了，近几年很多新框架参照了类似的用法。)

在这个基础上，我将自己使用querydsl中用到的一些功能包装了一下，就有个这个框架。前面已经说过querydsl的查询构建界面(Facade)非常好，所以我针对对象构造与反射等场合作了重写，以期将性能推到极致，就此使用了好多年，功能上逐步接近我对数据库访问工具的理想期望。

## 一点感想

这个框架可以说是无心偶得，今后也会佛系维护。
本框架的使用建议是取代JPA，如果是JPA的补充，那么Spring-data和querydsl-jpa已经做得很好，没有必要画蛇添足。实际上我本人也是从JPA路线转换过来，大概经历了这样几个步骤

- 使用MyBatis，在一个8人团队并且配备了开发DBA的长达两年的维护项目中，在DBA指导下需要频繁优化数据库结构和查询语句，多人修改的、分散的、大量多表关联的SQL语句和片段维护，由于没有编译器和类型安全的检查，耗费了团队极大的精力。
- 使用JPA和JPQL、QueryBuilder（从流行实现逐步更换为自有JPA实现，参见拙作GeeQuery）
- 使用Spring-data，发现并使用Spring-Data引入的queryDSL作为查询构建器。我在使用querydsl后就发现使用它编写的业务代码可读性很强且没有冗余代码，尤其是很好地解决了数据库访问的编译期检查问题。
- 某一天，我这样想到：querydsl-jpa作为查询构建器可以处理复杂的数据库访问，而JPA能提供的无非就是单表增删改查、级联和延迟加载功能。
  用querydsl把单表增删改封装成常用的JPA增删改查几乎没有难度。对于级联和延迟加载功能似乎也不是非要不可，那我还留着JPA干啥？



2017：有了前述想法后，说干就干，去除了JPA，仅留下querydsl-sql模块。本着最小修改的原则，对QueryDSL的监听行为进行扩展，从而可以得到更详细的日志信息。

2018：性能演进
既然打算今后长期使用了，对性能吹毛求疵的我自然不能接受原生的反射操作，于是进行了优化。这个框架就此诞生。增加了基于ASM自动生成动态类来完成字段拼装对象，无反射调用，还有一些代码BUG的修改。

2019~2023：自用阶段
之后就是自己用得非常爽快，期间仅对一些常用的功能进行了小改，使得代码更简洁。如自动时间戳、自动生成GUID等。

2024：扩展改造
在使用过程中，阅读源码中发现原作者一开始是想要支持DDL语法的，后来不知道为什么没有再支持了。可能确实使用场景不太多，总归有点小缺憾，由于我早年在GQ上写过相关的功能，于是花了不少时间在目前的框架上支持了DDL语法。
另外还有些朋友喜欢无代码自动生成，无Query class的纯POJO用法，为此也作了一些适配来降低使用门槛。

今后：保持轻量是维护的宗旨，不会再考虑加入什么乐观锁、词法分析器、分库分表、内置连接池之类的东西，虽然都写过，但是将它们糅合在一起没有必要。



最后：如果有使用下来觉得不错的朋友，无需给这个项目Star，请 Star [QueryDSL](https://github.com/querydsl/querydsl) 项目，各位觉得好的设计都来自QueryDSL，我只是为方便自己做了一些微不足道的修改而已。

## Java常见数据库访问的技术路线

### JPA路线

对比下表可发现，该路线对于 单表应用/ 小规模企业应用 的开发者是较为适合的。但是要想精通，需要专门学习框架自身知识体系——HQL / JPQL / QueryBuilder/ QueryDSL-JPA /SpringData-JPA /Hiberbate自身的对象管理和缓存机制 等等。

* 这也是整个JPA路线的问题——技术栈很深，但和数据库设计 / SQL优化等不在一个方向上。
* 抽象的JPQL为了解决兼容所有RDBMS的目的，有很多限制，无法最大化利用数据库的特性（比如 RowId, 窗口分析函数等）。

|      | JPA / Hibernate                                              | Spring Data -JPA                                             | QueryDSL-JPA                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 介绍 | 纯面向对象的数据访问，但实际<br />关系数据库的能力很难用一个虚拟的“对象库”代替。<br />因此需要使用HQL语言完成复杂查询。<br />JPA为了替代HQL，设计了QueryBuilder，但是API也比较复杂，并且JPA还设计了JPQL查询语言。<br />加上各种缓存、投影等复杂操作，入门易精通难 | Srpingframework针对JPA进行的封装（也封装了其他很多持久层框架），保留了JPA的所有功能 | 思路与Spring-Data如出一辙，API更易用。一般搭配搭配Spring Data-JPA使用，该路线的终极解决方案。 |
| 优点 | * 单表操作极其简便  <br />* @OneToOne @OneToMany @ManyToOne等注解，多表关联和延迟加载无需编码<br />* LOB字段延迟加载 | * JPA的所有优点<br />* 基于接口定义的方法名自动生成实现代理<br />* 引入querydsl-jpa作为替代的查询构建器。比JPA规范更符合开发者直觉。 | * 搭配Spring data-JPA使用，具有前者的全部优点<br />* 复杂查询构建方便 |
| 缺点 | 自由度较低<br />性能难控制<br />性能依赖缓存，而在多实例应用中，数据库层级的缓存存在无法刷新问题<br />低层级的缓存在复杂业务中不能代替粗粒度的业务数据缓存，整个缓存架构变得更复杂 | * JPA的所有缺点<br />* 本质上还是基于JPA的，要精通还是要深入学习JPA的所有知识<br /> | * JPA的所有缺点<br />* 三套框架的学习成本，                  |

### 数据访问层常用路线——JDBC路线

对比下表可以发现，虽然是JDBC路线，但querydsl-sql是所有框架中唯一做到以下两点的框架：

* 开发者无需编写 xxQL （HQL / JPQL /SQL），仅需掌握**一套API**即可完成（在不同RDBMS上的）几乎所有数据库操作。
* 开发者无需接触JDBC API，无需自行处理结果映射。

|      | SpringData -JDBC /JDBCTemplate                               | querydsl-sql                                                 | querydsl-sql-extension<br />(本框架)                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 介绍 | Srpingframework针对JDBC的封装，帮助开发者完成从JDBC到Java字段的简单映射，提升效率。 | 对数据库和SQL特性进行建模，提供了直观、简便的API。<br />内部使用了AST（抽象词法树）来描述针对数据库访问请求建模、 | 在querydsl-sql基础上封装。保留了querydsl-sql的特点。         |
| 优点 | * 基于接口定义的方法名自动生成实现代理                       | * 虽然是JDBC路线，但AST的模型包装了几乎所有SQL操作，开发者无需编写SQL，无需字符串拼接。<br />* 提供了各种数据库到java对象返回结果的映射（单列数据/多表任意列返回/指定列数据等）<br />* 数据库可移植性： 通过SQL AST + SQL方言模版，能做到一套数据库访问模型通吃所有数据库类型。一次编写，所有数据库上可运行。 | * querydsl-sql的所有优点<br />* 性能极致（参见后文）<br />* 单表等简单场合的API操作无需编码实现，解决开发效率问题。<br />* 支持近年来流行的Lambda代替数据表模型，无需生成Quey class. |
| 缺点 | * 封装程度不高，开发者需要熟练掌握SQL和JDBC规范，<br />* 复杂映射需要自行处理JDBC ResultSet对象。<br />* 不提供任何辅助数据库可移植性的特性。 | * 提供的API基于SQL AST模型，有种用java语言编写SQL的感觉，单表等简单操作也要编码实现，效率不够高 | *在本路线框架中没发现缺点。对比JPA类框架，没支持自动级联（@OneToOne @OneToMany等）和延迟加载，但提供了便捷的多表Join query和数据返回映射。 |

> 其实所有框架都是在JDBC上的封装，级联和延迟功能要支持一下也不麻烦，未来可能通过SPI扩展方式提供。

### Mixed路线

这条路线也是基于JDBC封装的，但都基于MyBatis框架。而不直接使用 JDBC。
进入这条路线基本可以放弃数据库可移植性了。因为MyBatis核心是SQL语句拼接而不是AST，因此最终数据库访问模型是用SQL字符串表达的。不过MB的支持者用了SQLParser之类的词法分析器来试图帮助这类框架提升数据库可移植性，以及一些基于MyBatis上层框架也采用了类似AST的模型来表达复杂查询，尤其是国内朋友各种对MyBatis进行“大修大补”的框架，使得这条路线在今天依然是最为流行的路线。但底层的架构决定了这条路线的上限。要解决数据库移植性问题，和重写一套基本没有区别。

>  当然数据库可移植性不一定要在访问框架层解决，还可以通过JDBC驱动（在驱动中通过词法分析修改SQL的行为）、中间件（直接解析数据库网络通信协议）、多语言数据库（现在大多数云数据库和国产数据库支持语法兼容模式）来解决。所以这可能不是什么大问题。

|      | MyBatis                                                      | MyBatis Flex/Plus等                                          |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 介绍 | 很老的框架，基本不更新了。基于JDBC封装，<br />提供了良好的SQL生成引擎和对象映射机制。 | 基于MyBatis的封装。                                          |
| 优点 | * 简便、流行、易学、轻量<br />* 不错的性能                   | * 简便、流行、易学、轻量<br />* Flex提供了自动生成数据表模型的机制（类似querydsl的Query class，或JPA的元模型）<br />* Plus提供了Lambda代替数据表模型的机制 |
| 缺点 | * 几乎没有对数据库可移植性帮助的特性<br />* 手工编写SQL开发效率不高。<br />* 无法使用静态工具（如编译器）对SQL<br />进行编译检查<br /> | * API能解决部分甚至大部分操作请求，但仍需要开发者编写部分SQL片段<br />* 解决了MyBatis开发效率的问题<br />* 其他MyBatis的缺点 |

