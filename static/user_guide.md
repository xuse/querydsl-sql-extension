# User Guide

- [User Guide](#user-guide)
	- [1 Using GenericRepository](#1-using-genericrepository)
	- [2 Multiple API Styles](#2-multiple-api-styles)
		- [Preparations](#preparations)
		- [Usage](#usage)
	- [3 Usage Overview](#3-usage-overview)
		- [Basics](#basics)
		- [Create a Business Repository](#create-a-business-repository)
		- [Obtain Repository Quickly](#obtain-repository-quickly)
		- [Using Query Class](#using-query-class)
		- [Using SQLQueryFactory](#using-sqlqueryfactory)
		- [Using Record Data Types](#using-record-data-types)
	- [4 Table Structure Annotations](#4-table-structure-annotations)
		- [@TableSpec](#tablespec)
		- [@ColumnSpec](#columnspec)
		- [@Comment](#comment)
		- [@UnsavedValue](#unsavedvalue)
		- [@HashPartition](#hashpartition)
		- [@RangePartition](#rangepartition)
		- [@ListPartition](#listpartition)
	- [5 Other Annotations](#5-other-annotations)
		- [@InitializeData](#initializedata)
		- [@CustomType](#customtype)
		- [@AutoGenerated](#autogenerated)
		- [@ConditionBean](#conditionbean)
	- [6. Package Scanning](#6-package-scanning)
		- [Automatic Scanning and Initialization of Database](#automatic-scanning-and-initialization-of-database)
		- [Ensure Initialization Only Once](#ensure-initialization-only-once)
		- [Distributed Lock](#distributed-lock)
	- [7. API for Maintaining Database Structure](#7-api-for-maintaining-database-structure)
		- [Examples of Table Maintenance](#examples-of-table-maintenance)
		- [Example of Partition Operations](#example-of-partition-operations)
		- [Permission Issues](#permission-issues)
		- [MySQL Online DDL (Partial Support)](#mysql-online-ddl-partial-support)
	- [8. FAQs / Miscellaneous Features](#8-faqs--miscellaneous-features)
		- [Compatibility for Sharding in Business Layer](#compatibility-for-sharding-in-business-layer)


## 1 Using GenericRepository

Many Java programmers are accustomed to creating a Repository object for each table and its corresponding mapping class, encapsulating a data access layer. The data access layer can limit the upper-level business logic from acquiring overly flexible database access capabilities. Each type of database access behavior needs to be encoded and implemented in the DAO/Repository object, which can enhance manageability and reusability for complex business logic.

Repository is just an extended Facade API of QueryDSL.

> QueryDSL possesses the strongest SQL model AST, but it is intended for advanced users who are proficient with various SQL syntaxes. Hence, the provided API is extremely powerful and flexible, which might not be favored by users or developers who do not require complex operations. However, the characteristic of a powerful engine is that it can virtually simulate the API styles of all similar frameworks in the industry. Here, we have selected some of the mainstream styles and wrapped them with some Facade to cater to the preferences of relatively traditional developers.

The GenericRepository provides common CRUD functionalities for a single table, as shown in the table below. Other personalized business logic can be coded and implemented within the Repository class.

A significant reason to recommend using a GenericRepository object is that it offers a more friendly API in the context of pure POJO (without Query class).

The examples in the subsequent sections of this article will be based on scenarios without a QueryClass.

| Method              | Function                                                         |      |
| ----------------- | ------------------------------------------------------------ | ---- |
| load              | Load one object by primary key.                              |      |
| loadBatch         | Retrieve objects in bulk by primary key.                     |      |
| findByExample     | Retrieve records based on an example query object.           |      |
| find              | Retrieve records based on user-specified query conditions.   |      |
| insert            | Insert a record.                                             |      |
| insertBatch       | Batch insert records.                                        |      |
| delete(ID)        | Delete one record by primark key.                            |      |
| delete            | Delete records based on user-specified query conditions.     |      |
| deleteByExample   | Delete records based on an example query object.             |      |
| update(ID,Object) | Update one record by primary key.                            |      |
| updateByKeys      | Update other fields of the object based on the specified fields as the WHERE condition. |      |
| update            | Update records on user-specified query conditions.           |      |
| count             | Count records based on user-specified query conditions.      |      |
| countByExample    | Count records based on  an example query object.             |      |
| query             | Create a generic query builder.                              |      |
| findByCondition   | Use the @ConditionBean annotation to create a query parameter class. Fields in this class can use the @Condition annotation for query operators to facilitate typical web pagination queries. |      |

> Performing multi-table operations and more complex SQL can be done using the native API of QueryDSL, specifically the SQLQueryFactory series of APIs. This is the best QueryBuilder I have seen in the industry.

## 2 Multiple API Styles

### Preparations

Step.1 To complete the following examples, you can start by creating a simple POJO.

```java
@Data
@TableSpec(name="test_foo",primaryKeys="id",collate = "utf8mb4_general_ci")
@Comment("a table to test")
public class Foo {
    @ColumnSpec(autoIncrement = true)
	private int id;
    
    @ColumnSpec
   	private String name;
    
    @ColumnSpec
   	private Instant created;
    
   	@ColumnSpec(size=16384)
	private String content;
}
```

Step.2 Ceating Table
You can create it manually. If you are sure the program has DDL operation permissions, you can also use the following Java code to create the database table.

```java
SQLMetadataQueryFactory metadata=factory.getMetadataFactory();
metadata.createTable(()->Foo.class).ifExists().execute();
```

Step.3 Obtain a Repository Object

You can refer to [Chapter 3: Usage Overview](#3-usage-overview) to obtain a Repository object. Once you have the object, you can experience its functionalities. Below, we introduce the usage of different API styles with an example query.

### Usage

**Traditional Style**

The traditional style has weaker support for complex query functionalities, such as the inability to support Between conditions.

```java
Foo foo=new Foo();
foo.setName("Jhon");
foo.setCreated(Instant.now());
repository.findByExample(foo);	
```

**Lambda Style**

In the official API of QueryDSL, users are required to create a class starting with `Q`, known as a query class. Using this query class model can significantly simplify the syntax and even allows direct use of various complex functions through the query class API. This query class functions similarly to the meta model usage in JPA.

Our framework extends the usage without the need for a query class. Instead of creating a query class, you can use lambda expressions. An example is shown below:

```java
repository.query()
	.eq(Foo::getName, "Jhon")
	.between(Foo::getCreated, DateUtils.getInstant(2023, 12, 1), Instant.now())
	.findAndCount();
```

**MyBatis-Plus Style**

MyBatis supports lambda style usage, with the difference that it relatively traditionally divides the query into two objects — one for recording query conditions and another for the framework session (commonly SqlSession or Mapper in MyBatis. In other frameworks, there may be Session, Context, EntityManager, etc., under different names).

```java
	LambdaQueryWrapper<Foo> wrapper=new LambdaQueryWrapper<>();
	wrapper
		.eq(Foo::getName, "Jhon")
		.between(Foo::getCreated, DateUtils.getInstant(2023, 12, 1), Instant.now())
        .orderByAsc(Foo::getId);
	//Fetch top records and the total count.
	Pair<Integer, List<Foo>> results=repo.findAndCount(wrapper, 10, 0);
```

**MyBatis-Flex Style**

```java
	LambdaColumn<Foo, String> name = Foo::getName;
	LambdaColumn<Foo, Instant> created = Foo::getCreated;
	List<Foo> list= repo.find(q->q.where(name.eq("Jhon").and(created.between(DateUtils.getInstant(2023, 12, 1), Instant.now()))));	
```

**Using a web form-associated object**

````java
	//Define a class that matches the structure of the query form, and set various query and pagination conditions through annotations. 
	@Data
	@ConditionBean
	public static class FooParams{
		@Condition(Ops.STRING_CONTAINS)
		String name;
		
		@Condition(Ops.BETWEEN)
		Date[] created;
	}
	//Similar to common single-table queries: empty strings will be automatically omitted and not used as `WHERE` conditions.
	FooParams params=new FooParams();
	params.setName("Jhon Smith");
	params.setCreated(new Date[] {DateUtils.get(2023, 12, 1), new Date()});
	repo.findByCondition(params);
````


## 3 Usage Overview

**Import the Library**

This document uses a Spring integration example, so it depends on the `querydsl-sql-extension-spring` package. If Spring integration is not used, you can rely solely on the `querydsl-sql-extension`.
> If you want to use without Springframework, Refer to this document [Without Springframework](static/without_springfrwmework.md)

```xml
<dependency>
	<groupId>io.github.xuse</groupId>
	<artifactId>querydsl-sql-extension-spring</artifactId>
	<version>${querydsl-sql-extension.version}</version>
</dependency>
```

### Basics

This framework directly depends on the `querydsl-sql` library, and its primary usage is consistent with QueryDSL. However, the initialization method differs from QueryDSL.


**Initialization** (Work together with the Spring transaction management)

```java
	@Bean
	public com.github.xuse.querydsl.sql.SQLQueryFactory factory(DataSource ds) {
        return com.github.xuse.querydsl.sql.spring.QueryDSLSqlExtension
            .createSpringQueryFactory(ds, querydslConfiguration());
	}

	private ConfigurationEx querydslConfiguration() {
        //Change to the SQLTemplates of your RDBMS.
		SQLTemplates templates = new MySQLWithJSONTemplates();
		ConfigurationEx configuration = new ConfigurationEx(templates);
		configuration.addListener(new QueryDSLSQLListener());
        configuration.scanPackages("{your entity packages}");
        //Add you confiuration here.
		return configuration;
	}

	//For other frameworks that use the same transaction manager (e.g., MyBatis, JDBC Template, etc.), the transaction is shared.
	@Bean
	public PlatformTransactionManager tx(DataSource ds) {
		return new DataSourceTransactionManager(ds);
	}
```

### Create a Business Repository

Write your own Repository class and add its package name to the Spring auto-scan path.

```java
import org.springframework.stereotype.Repository;
import com.github.xuse.querydsl.entity.MyEntity;
import com.github.xuse.querydsl.repository.GenericRepository;

@Repository
public class MyEntityRpository extends GenericRepository<MyEntity, Integer>{
	//For usage of GenericRepository, see Chapter 2.
	//If you need to write your own business logic for the Repository layer, you can add methods here.
}
```

### Obtain Repository Quickly

In another way, the Repository can be directly obtained via the SQLQueryFactory object.

```java
CRUDRepository<Foo, Integer> repository = factory.asRepository(()->Foo.class);
```

### Using Query Class

> For users who have not used QueryDSL and are using this framework for the first time, it is recommended to use the pure POJO approach. This section can be skipped.

This section introduces how to use the code generation tool based on QueryDSL within this framework.
Since there is no current functionality to automatically generate Java code from the database, you can first use the "code generation via maven" section in the official documentation to generate the code. Some modifications to the generated code may be necessary.

**Using Maven Plugin to Generate Query Class**

 ```xml
	<plugin>
		<groupId>com.querydsl</groupId>
		<artifactId>querydsl-maven-plugin</artifactId>
		<version>5.0.0</version>
		<executions>
			<execution>
				<goals>
					<goal>export</goal>
				</goals>
			</execution>
		</executions>
		<configuration>
			<jdbcDriver>com.mysql.cj.jdbc.Driver</jdbcDriver>
			<jdbcUrl>jdbc:mysql://host:port/database?useUnicode=true</jdbcUrl>
			<jdbcUser>username</jdbcUser>
			<jdbcPassword>password</jdbcPassword>
			<exportBeans>true</exportBeans>
			<packageName>xxx.xxx.dal.domain</packageName>
			<targetFolder>${project.basedir}/src/main/java</targetFolder>
			<tableNamePattern>%</tableNamePattern>
			<beanAddToString>true</beanAddToString>
		</configuration>
	</plugin>
 ```



**Modifications on generated code**

The generated code still needs some modifications. For example, the generated code is as follows

```java
@Generated("com.querydsl.sql.codegen.MetaDataSerializer")
public class QAaa extends com.querydsl.sql.RelationalPathBase<Aaa> {

	private static final long serialVersionUID = -1;
    public static final QAaa aaa = new QAaa("AAA");
    public final NumberPath<Long> cBigint = createNumber("cBigint", Long.class);
```

To use the extended functionality, replace the `com.querydsl.sql.RelationalPathBase` class mentioned above with `com.github.xuse.querydsl.sql.RelationalPathBaseEx`.
After the replacement, it will be:

```java
@Generated("com.querydsl.sql.codegen.MetaDataSerializer")
public class QAaa extends com.github.xuse.querydsl.sql.RelationalPathBaseEx<Aaa> {

private static final long serialVersionUID = -124472086;
    public static final QAaa aaa = new QAaa("AAA");
    public final NumberPath<Long> cBigint = createNumber("cBigint", Long.class);
```

After the replacement, in the `addMetadata()` method, you can use more APIs to define the data structure and framework behavior.
Additionally, if you are not satisfied with the types of some fields in the generated objects, you can manually modify them as well.


**Recommendation: Use Primitive Types**

Primitive types refer to `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`.

Some ORM frameworks do not recommend using primitive types in Bean definitions because the framework cannot determine whether the user has assigned a value to the field using operations like `object == null`. However, using wrapper types such as `Integer` or `Long` also introduces additional burdens—the code frequently needs to check if the field is null, which affects code readability and incurs performance costs due to boxing and unboxing operations.

> Best Practice: Map NOT NULL database columns to primitive types.

In a well-designed database, most numeric columns should be NOT NULL columns. The querydsl-sql-extension encourages users to use primitive types for mapping non-null columns. In querydsl, many APIs explicitly specify paths for operations, so there is no ambiguity regarding whether a primitive type value is set. However, some APIs still attempt to "automatically" determine whether a field should be written to or updated in the database. In such cases, you can inform the framework which values should be considered as null (unset).

```java
@UnsavedValue(UnsavedValue.MinusNumber)   //Negative Values Are Considered Invalid (Equivalent to Null).
private int dataInt;
```

Or

```java
//Zero is Considered Invalid (Equivalent to Null).
addMetadata(id, ColumnMetadata.named("ID").withIndex(1).ofType(Types.INTEGER)).withUnsavePredicate(UnsavedValue.Zero);
```

Once the issue of invalid values is resolved, primitive types will not cause additional complications. Further analysis is available in detailed documentation.

### Using SQLQueryFactory

> The native style of QueryDSL is powerful and very flexible, making it difficult for beginners to master. Readers with experience only in JPA-like frameworks can skip this section for now.
> 
This section introduces basic database operations using the QueryDSL syntax. SQLQueryFactory is the main entry point for database access in most cases. Below is a simple operation example.

**Insert DEMO**

```java
QFoo t1 = QFoo.foo;
Foo a = new Foo();
a.setName("Jhon");
a.setGender(Gender.FEMALE);
Integer id = factory.insert(t1).populate(a).executeWithKey(Integer.class);
System.out.println("The auto increment value is " + id);	
```

**Select DEMO**

```java
Foo selected = factory.selectFrom(t1).where(t1.id.eq(id)).fetchOne();
```

**Update DEMO**

```java
long count = factory.update(t1)
       .set(t1.created, Expressions.currentTimestamp())
       .set(t1.name, "李四")
       .where(t1.id.eq(1))   
       .execute();
System.out.println(count + " records was updated.");	

//Update DEMO2
Foo b = new Foo();
b.setName("Jhon");
b.setGender(Gender.FEMALE);
long count = factory.update(t1)
       .populate(b)
       .where(t1.id.eq(1))   
       .execute();
```

**Update with comparisons**

*  For comparison updates, only the changed fields are set. If there are no differences between the two objects, the database will not be written to.

```java
Foo oldRecord = factory.selectFrom(t1)
     .where(t1.id.eq(id)).fetchOne();
Foo b = new Foo();
b.setName("Jhon");
b.setGender(Gender.FEMALE);
factory.update(t1)
 	.populateWithCompare(a, oldRecord)
	 .where(t1.id.eq(id))
	 .execute(); 
```

**Delete DEMO**

```java
factory.delete(t1).where(t1.id.eq(id)).execute();
```

**Complex Selection DEMO**

```java

	QCaAsset t2=QCaAsset.caAsset;
	List<Tuple> tuples=factory.select(t1.name,t1.gender,t2.content,t2.code)
	    .from(t1)
		.innerJoin(t2).on(t1.id.eq(t2.id))
	    .where(t1.name.eq("Zhangsan"))
	    .fetch();
```



For more usage methods, refer to the QueryDSL documentation:** [Querydsl-sql Documentation](http://querydsl.com/static/querydsl/latest/reference/html/ch02s03.html).

The `querydsl-sql-extension` extends many functionalities based on the native version. For details, refer to the javadoc.

### Using Record Data Types

> To use the Record feature, you must use JDK version 16 or above.
> This framework has specially handled access to Record objects, making it not dependent on JDK version 16 or above. The current framework can still be used with Java versions 8~22.

Table structure definition annotations can be used normally on record types, with slight differences compared to regular classes.

```java
@TableSpec(
	name="record_foo",
	primaryKeys = "id",
	keys = {
		@Key(type = ConstraintType.UNIQUE,path = {"name"}
	)
})
@Comment("The record table mapping.")
public record Foo(
		@ColumnSpec(autoIncrement = true,name = "foo_id",nullable = false,type = Types.BIGINT,unsigned = true)
		@Comment("an autoincreament primary key")
		long id,
		
		@ColumnSpec(name="username",nullable = false,size = 128)
		@Comment("the name of users.")
		String name,
				
		@AutoGenerated(value = GeneratedType.CREATED_TIMESTAMP,overwrite = true)
		@ColumnSpec(name="create_time",nullable = false, defaultValue = "current_timestamp()", type=Types.TIMESTAMP)
		Date created
	){}
```

The genral usage is the same as previously mentioned, but referencing field names of record types is more concise.

```java
	CRUDRepository<Foo, Long> repository = factory.asRepository(()->Foo.class);
	List<Foo> result = repository.query()
			.eq(Foo::name, "Joey")
			.or(
				(query) -> query.lt(Foo::created, new Date())
			).fetch();
```

When using record types, be aware of the following characteristics:

* Since Record objects are immutable and all fields cannot be set, the `@AutoGenerated` write-back feature will automatically become ineffective. (A log message will indicate that the write-back values are discarded, but no exception will be thrown.)

  

## 4 Table Structure Annotations

When not creating a QueryClass, all database table characteristics need to be defined through annotations. The currently supported annotations are:

### @TableSpec

This can only be added to the class level to describe the characteristics of the database table.

```java
@TableSpec(
schema ="test" 	  //The schema name，Generally, services do not access across schemas, so you can leave it blank. For complex applications, redirect rules can be configured in the test environment.
name = "ca_foo",  //The table name
primaryKeys = "id", //field name of the primary key, can be a list.
collate = "utf8mb4_general_ci", //the charset and collating. This only takes effect on certain databases, such as MySQL.
keys = {
		@Key(path= {"code"},type=ConstraintType.UNIQUE),//Define a UNIQUE index
		@Key(path= {"content"},type=ConstraintType.FULLTEXT),//Define a fulltext index. This only takes effect on some certain databases, such as MySQL.
	}
check = {
		@Check("updated >= created")  //A CHECK constraint, will be skipped on unsupported databases.
	}
)
public class Entity{    
```

### @ColumnSpec

Can only be added to fields, describing the characteristics of database columns.

```java
@ColumnSpec(
    name = "is_disabled", //Column name map to this field.
    type = Types.TINYINT, //Data type of the column. using constants defined in java.sql.Types.
    unsigned = true,  //Is the number unsigned (if the database supports unsigned number)
    nullable = false,  //Is the column nullable.
    defaultValue = "0", //Default value expression, for example, to define as an empty string, it should be written as "''".
	autoIncrement = false,//Is a auto increamenet column or not.
    size = 5,  //Defines the field length. For Decimal, it indicates the maximum length of the number. while for time and timestamp/datetime types, it indicates the precision of the fractional seconds.
    digits = 0 //When using the Decimal type, it defines the number of decimal places.
)
private int disabled;
```

### @Comment

Can be added to a class or field. When applied to a class, it represents the table comment; when applied to a field, it represents the database column comment.
Using the create table or refresh table function will write the comments into the database. For databases that do not support comments (such as Derby), it will be automatically ignored.

```
@Comment("Comment on table or column")
```

### @UnsavedValue

Can be added to a field to describe the range of invalid (ignored) values for that field. It is typically used for primitive type fields.

```
	//Setting 0 or negative numbers as invalid values, will prevent the default '0' from being written to the database during insert or update operations.
	@UnsavedValue(UnsavedValue.ZeroAndMinus)
	private int id;
```

### @HashPartition

Can only be added to a class to specify partitioning based on the Hash value of a field. (Applicable only to databases that support table partitioning).

```
@HashPartition(
	type=HashType.KEY, columns = {"asset_name"}, count = 4
)
```

### @RangePartition

Can only be added to a class for partitioning based on numeric ranges. The values can be numbers or date-time values. (Applicable only to databases that support table partitioning).

```java
@RangePartition(
	columns = "recordTime",  //the java field name of partition columm.
	auto = @AutoTimePartitions(  //Automatically calculate the partitions based on the current time.
		unit = Period.DAY,     	//Partition by days
		periodsBegin = -2,		//The earliest partition is two days ago
		periodsEnd = 3,			//The latest partition is three days later
		createForMaxValue = true,//Additionally, create a max value partition (if data with a date later than three days from now is written into this partition).
		columnFormat = ColumnFormat.NUMBER_YMD //If the database column uses a time-based type, configuration is not required. However, if the column is of number or varchar type, the format must be specified. In this example, the database column is an eight-digit number representing the year, month, and day.
	)
)
```

### @ListPartition

Can only be added to a class for partitioning based on enumerated values. (Applicable only to databases that support table partitioning).

```java
@ListPartition(
	columns="name",		//Partition by values of this field.
	value={				
		@Partition(name = "p1",value="'0','1','2','3'"),
		@Partition(name = "p2",value="'8','9','a','b'"),
		@Partition(name = "p3",value="'4','5','6','7'"),
		@Partition(name = "p4",value="'c','d','e','f'"),
	}
)
```

## 5 Other Annotations

Extended usage refers to the functionalities encapsulated by the framework. The capabilities corresponding to these annotations do not depend on database DDL.

### @InitializeData

These annotations can only be added to a class. During initialization, a resource file is used to merge the initialization data into the table.

```java
@InitializeData(
	//Specifies the resource file name. The resource file should be in CSV format. You can use com.github.xuse.querydsl.init.InitDataExporter to generate the file.
	value="table_init_data", 
	//Specifies the character set of the resource file
	charset ="UTF-8",
	//When set to true, if there is already data in the data table, data initialization will not be carried out.
	forEmptyTableOnly=false, 
	//By default, if data already exists in the table, the primary key is used for updates. However, if the primary key has no business significance, several business keys can be used for the update.
	mergeKeys = {"name"}，	
	//Specifies whether null values in the data file should be written into the database when updating data.
	updateNulls = false,
	//Optionally, you can use a custom SQL script file instead of a CSV file. The two options are mutually exclusive.
	sqlFile = “”
)
```

### @CustomType

This annotation can only be added to a field. It is used for automatic serialization before writing to the database and automatic deserialization when reading.

```java
	//Stores complex types in the database in JSON format
	@ColumnSpec(type = Types.VARCHAR, size=1024)
    @CustomType(JSONObjectType.class)
    private CaAsset asserts;

	// Formats a string into DateTime type before storing it in the database
    @CustomType(value=StringAsDateTimeType.class,parameters = "MM/dd/yyyy HH:mm:ss") 
    private String updateTime;

	//Stores enum values in the database using custom numeric indexes
    @CustomType(EnumByCodeType.class)
	private Gender gender;
```

### @AutoGenerated

Only applicable to fields. If no value is specified before writing to the database, an auto-generation strategy will be used to generate it. For time-based fields, the `current_timestamp()` function of the database is used to set the field value, recording the time on the database side.

```java
	//Automatically assigned when the record is created; subsequent updates will not change this value by default.
	@AutoGenerated(GeneratedType.CREATED_TIMESTAMP)  
	private Date created;

	//Automatically assigned both when the record is created and when it is updated.
	@AutoGenerated(GeneratedType.UPDATED_TIMESTAMP)  
	private Date updated;

	//Automatically generates an ID using a Snowflake ID generator when the record is created (the Snowflake ID generator requires global initialization once).
	@AutoGenerated(GeneratedType.SNOWFLAKE)  
	private long id;
```

### @ConditionBean

 @ConditionBean annotation example that supports designing query objects.

 This function is mainly suitable for relatively fixed query patterns. 

 For instance, a web page that supports retrieval with several conditions, where the requirements are generally as follows: supports combined retrieval with several conditions, with the name condition supporting fuzzy matching (Like ?%), date condition supporting range setting, and other conditions requiring exact matches. All the above fields can be left empty to indicate no restriction. 

 For this scenario, you can design the conditions as corresponding query objects and use the @ConditionBean and @Condition annotations to mark the operation of each field.


```java
@Data
@ConditionBean(limitField = "limit",offsetField = "offset")
public class FooQueryParams {
	@Condition(Ops.STARTS_WITH)
	private String content;
	
	@Condition(Ops.GT) 
	private int authType;
	
	@Condition(Ops.EQ)
	private String code;
	
	@Condition(Ops.BETWEEN)
	private Date[] createTime;
	
	private Integer limit;
	
	private Integer offset;
}
```

When use the bean which defined above:

  ````java
  	QFoo t = QFoo.foo;
  	FooQueryParams p = new FooQueryParams();
  	......
  	p.setLimit(100);
  	p.setOffset(2);
  	Pair<Integer, List<Foo>> countAndData = factory.findByCondition(p);
  ````


## 6. Package Scanning

The package scanning feature is generally configured during system initialization and is used for executing automatic database operation tasks. It also completes the registration for entity classes.

### Automatic Scanning and Initialization of Database

**Introduction:** When the application starts, it scans the entities under the specified package. Then—

* Find entities classes, scan the annotation, then register custom data type mappings into a  global context.
* Automatically creates tables, indexes, constraints, etc., in the database.
* If the table already exists in the database, it automatically modifies the table structure to align with the Java model. (Features like column deletion and index deletion can be disabled)
* If initialized data is configured, it can merge the preset initialization data into the data table.
* It can create an initialization configuration table in the database to let user control whether to modify or merge data in this table in the future.

All of DDL features come with multiple control switches to prevent accidental deletion of tables or columns, which could result in data loss.

```java
configuration.getScanOptions()
	.allowDrops()    //Allows modification of existing tables, and allows deletion of columns, indexes, and constraints
	.setCreateMissingTable(true) //Allows creation of missing tables
    .setDataInitBehavior(DataInitBehavior.FOR_ALL_TABLE) //Initializes data for all scanned entities
	.detectPermissions(true)  //First attempts to check if the current account has DDL permissions; if not, subsequent DDL operations will not be executed
	.useDistributedLock(true) //When enabled, table structure modifications and initialization actions will attempt to obtain a distributed lock, see below for details
	.useDataInitTable(true);  //Enables the initialization configuration table, automatically creating a table that records initialization behaviors, also used as a distributed lock. It is recommended to enable this in multi-instance concurrency scenarios.
    
configuration.scanPackages("com.xxx.xxx");
```

**Disable DDL execution**

Although the framework uses 'Online SQL' to modify existing database tables, there is still a possibility that executing DDL might lock tables. In high-load production environments with particularly high availability requirements, it is recommended to disable the feature of executing DDL during startup. 

```java
configuration.getScanOptions()
    .disableDDL();
configuration.scanPackages("com.xxx.xxx");
```

**Disable Data Initialization**

If you are concerned that the automatic data update functionality might impact the production environment, you can disable the initialization of data writing, or even prohibit all database initialization activities.

```java
//Disable table data initialization feature
configuration.getScanOptions().disableDataInitialize();
configuration.scanPackages("com.xxx.xxx");

//Prohibit all automatic database operations
configuration.getScanOptions().disableAllDatabaseOperation();
configuration.scanPackages("com.xxx.xxx");
```

### Ensure Initialization Only Once

If you want the initialization action to be executed only on the first run, you need to enable the initialization behavior log table. This is done by using `.useDataInitTable(true);`.

This table uses the name of the business table as the primary key. If the table has already been initialized, the `is_disabled` column value will be updated to 1, and the same table will not be re-initialized on the next startup.

The name of the log table is `querydsl_auto_init_data_log`. When this feature is enabled, **the system will attempt to create this table automatically**. However, if the application does not have DDL permissions, you may need to create this table manually. The SQL statement for creating the table is as follows (using MySQL as an example):

```sql
CREATE TABLE querydsl_auto_init_data_log (
  table_name VARCHAR (128) NOT NULL COMMENT 'table name.',
  is_disabled TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '1 - Data init on this table is disabled. 0 - data init enabled.',
  init_records SMALLINT UNSIGNED NOT NULL DEFAULT 0 COMMENT 'records saved on the last write process.',
  last_init_time DATETIME NULL,
  last_init_user VARCHAR (128) NULL,
  last_init_result VARCHAR (400) NULL,
  PRIMARY KEY (table_name)
) COMMENT 'informations about data initialize by querydsl-sql-extenstion'
```

### Distributed Lock

As mentioned earlier, to prevent multiple instances from simultaneously scanning and modifying a database, you can configure a distributed lock. Once enabled, there are two ways to implement it.

**Using a Database Table as a Distributed Lock**

Using a database table as a distributed lock is the default implementation.

If the `useDataInitTable(true)` feature is enabled, the corresponding data table will automatically be used as the distributed lock. If DDL permissions are detected, **the system will automatically create this table.**

**Using Other Middleware for Distributed Lock (ZK, Redis, etc.)**

Set up a custom distributed lock during initialization.

```java
// Implement a distributed lock yourself
public class MyLockProviderimplements DistributedLockProvider{
	public DistributedLock getLock(String lockName, int maxLockMinutes){
		// Distributed lock implementation
	}
}

//Configure the custom distributed lock
ConfigurationEx configuration = new ConfigurationEx(templates);
configuration.setExternalDistributedLockProvider(new MyLockProvider());
```

## 7. API for Maintaining Database Structure

> Experimental feature. Due to limited personal resources, only partial dialect adaptations have been completed for certain databases (see the README.md for the list). However, the current framework's AST-based extension mechanism is highly robust, making it relatively easy to adapt to other mainstream databases. Enthusiasts are welcome to write their own dialects for further extension.

### Examples of Table Maintenance

**Drop table and recreate.**

```java
	QFoo t=QFoo.foo;
	SQLMetadataQueryFactory metaFactory = factory.getMetadataFactory();
	metaFactory.dropTable(t).ifExists(true).execute();
	metaFactory.createTable(t).execute();
```

**Alter table**

```java
	SQLMetadataQueryFactory metadata = factory.getMetadataFactory();
	QFoo t=QFoo.foo;
	metadata.refreshTable(t)
		.removeConstraintOrIndex("unq_${table}_name_version")  //The variable ${table} will be replaced with the actual table name.
		.addColumn(
				ColumnMetadata.named("new_column").ofType(Types.VARCHAR)
				.withSize(64).notNull(), String.class).defaultValue("")
				.build()
		.dropConstraint(true)
		.execute();
```

**Truncate table**

```java
	QFoo t=QFoo.foo;
	SQLMetadataQueryFactory metaFactory = factory.getMetadataFactory();
	metaFactory.truncate(t).execute();
```

**Add Index**

```java
	QFoo t=QFoo.foo;
	SQLMetadataQueryFactory metadata = factory.getMetadataFactory();
	metadata.refreshTable(QAaa.aaa)
		.createIndex("idx_foo_gender", t.gender)
		.execute();
```

### Example of Partition Operations

For databases that support table partitioning only, such as MySQL, PostgreSQL, Oracle, etc.

>  Currently, adaptation for MySQL and PostgreSQL has been completed.

**Creating Partitions**

```java
SQLMetadataQueryFactory metadata = factory.getMetadataFactory();
metadata.createTable(table).reCreate().execute();

//Here, reference the static model of the table (generated by the QueryDSL code generation tool). If this class does not exist, use LambdaTable<T> instead.
QPartitionFoo1 table = QPartitionFoo1.partitionFoo1;

metadata.createPartitioning(table)
		.partitionBy(Partitions.byHash(HashType.HASH, "TO_DAYS(created)", 4))
		.execute();
```

**Query Partition Informations**

```java
List<PartitionInfo> list=metadata.getPartitions(table.getSchemaAndTable());
```

**Clear Partition Settings (Without Deleting Data)**

```java
metadata.removePartitioning(t1).execute();
```

**Create Partitions Based on Time Range**

```java
metadata.createPartitioning(table).partitionBy(
	Partitions.byRangeColumns(table.created)
		.add("p202401", "'2024-02-01'")
		.add("p202402", "'2024-03-01'").build())
    .execute();
```

**Add an Additional Partition**

Add an Additional Partition. 
Note: Since the range of the new partition is included in the old partition, data may already exist in the old partition.
It is necessary to reorganize the data in the old partition into the new partition. Hence, the system will automatically use REORGANIZE PARTITION to move the data from the first partition to the new partition.

```java
metadata.addParition(table)
		.add("p20200101", "'2021-01-01'")
		.execute();
```

**Delete Partition (Including Data in the Partition)**

```java
metadata.dropPartition(table)
    .partition("p20200101").execute();
```

### Permission Issues

The previous section on [Automatic Scanning and Initializing Database] introduces the action of sniffing operation permissions when starting the scan. If it is found that there are no permissions such as CREATE, DROP, etc., then all DDL operations will not be executed.

### MySQL Online DDL (Partial Support)

>  MySQL began supporting Online DDL from version 5.x and improved it by version 8.x. The scope of Online DDL needs to be controlled based on specific environments. The current MySQL environment in hand is 5.6, so it has been adapted accordingly.
> The optimization for MySQL 8.x has not been done yet.

Online DDL can prevent blocking due to locks during DDL execution and avoid affecting users' DML operations. Online DDL means that during the execution of DDL, users are allowed to perform DML operations.

When executing DDL on MySQL databases, it will automatically be performed in Online mode to minimize interference with production environment business access.
For example, when modifying a data table, the algorithm and lock will be specified to ensure that the DDL operation does not affect the business during execution.

* The application of this feature does not mean that DDL execution has no impact on the data table. For high-availability systems running 24/7, DDL should still be executed during off-peak business hours.
* Online DDL was introduced in MySQL 5.x, and more Online DDL strategies are supported in 8.x. However, the dialects of 5.x and 8.x have not yet been distinguished, and currently, a relatively conservative strategy is followed based on 5.x.


## 8. FAQs / Miscellaneous Features

### Compatibility for Sharding in Business Layer

**This framework does not provide sharding functionality**

However, there is a scenario where the sharding rules and usage are relatively simple, and the business layer wishes to encapsulate the sharding itself. In such cases, it is necessary to dynamically change the table name based on business data. For this scenario, a mechanism is provided that allows the business code to adjust the table name itself.

```java
	//define a suffix of the table name
	TableRouting routing=TableRouting.suffix( "2024Q2");

	//Using the suffix strategy in DDL operation.
	SQLMetadataQueryFactory metadata=factory.getMetadataFactory();
	metadata.dropTable(t2).withRouting(routing).execute();
	metadata.createTable(t2).withRouting(routing).execute();
	
	//Using the suffix strategy in DML operation.
	List<Tuple> tuples=factory.select(t2.content,t2.code).from(t2)
	    .withRouting(routing)
	    .where(t2.name.eq("Test"))
	    .fetch();
	
	//If multiple tables need to adjust their suffixes in a single SQL statement, refer to the following.
	TableRouting routing=TableRouting.builder()
		.suffix(t1,"202406")
		.suffix(t2, "2024Q2")
		.build();
```

Hint: If the rules for database and table sharding are complex, it is recommended to use a special sharding layer under this framework, such as Sharding JDBC/Sharding Sphere.